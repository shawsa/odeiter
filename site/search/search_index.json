{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"odeiter An iterator-based python package for solving systems of differential equations. For example, to solve the initial value problem $$ \\begin{align} u''(t) &= -u \\\\ u(0) &= 0 \\\\ u'(0) &= 1 \\end{align} $$ we can express it as a first-order system $$ \\begin{align} \\vec{u}' &= \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\vec{u} \\\\ \\vec{u} &= \\begin{bmatrix}0 \\\\ 1 \\end{bmatrix} \\end{align} $$ then solve the system with a time-integrator like RK4 like so: >>> import numpy as np >>> from odeiter import TimeDomain, RK4 >>> u0 = np.array([0.0, 1.0]) >>> >>> def rhs(t, u): ... return np.array([[0, 1], [-1, 0]]) @ u ... >>> time = TimeDomain(0, 0.1, 4) >>> solver = RK4() >>> for u in solver.solution_generator(u0, rhs, time): ... # so something with the solution at this time ... print(u) ... [0. 1.] [0.09983333 0.99500417] [0.19866917 0.9800666 ] [0.29551996 0.95533654] [0.38941803 0.9210611 ] Why another ODE solver? The elephant in the room is scipy.integrate.sovle_ivp . Why would you use odeiter instead? If you want an array of your solution at all time points in a finite interval then solve_ivp is your best solution, but I found myself needing something more flexible. So I made odeiter which takes advantage of Python generators. Generators decouple the solver code from the looping body. In general, you don't want to simply compute the soltuion to your system. You want to compute the solution and do something with the solution. For example, the following animation was made using odeiter and it solves the system $$ x''(t) = -x, \\qquad x(0) = 0, \\qquad x'(0) = 1 $$ using 6 different solvers, simultaineously. At each time step it plots the solution, computes the relative erorr, and plots the relative error. This can be done with solve_ivp but one would have to store the entire solution for each solve in memory and then loop again to perform the plotting. That doesn't sound so bad for a system with only two variables (since it's a second order equation), but this becomes imensly important when you want to solve PDEs. For example, I used odeiter to solve a neuralfield eqution on a bumpy-sphere. A neural field equation is an integro-differential equation, so the resulting ODE had hundreds of thousands of dimensions, one for each sample point on the surface. At each time step, I plot the solution (left) and I also plot the maximum value of the solution (right) as a continuous path across the surface. Once a frame for the animation is generated, the solution at that time point is no longer requried so it is discarded and the memory is freed. Another advantage, is that generators are lazy. They don't compute the solution until you ask for it. This allows you to run simulations without a predetermined stoping condition. For example, the flowing animation shows two simulations created with odeiter where the difference is in the amplitudes of the forcing functions (magenta). The top simulation entrains so the solution (blue) rides the forcing function (magenta) indefinately, and achieves a stable traveling wave solution. In the bottom simulation, the solution rides the forcing function for a while but in the end it does not entrain because the forcing function is too weak. I tested many amplitudes and simulated until either they reached a traveling pulse solution or until the forcing term was separated from the solution by a certain distance. I was able to implement this simply without needing to know how long I would simulate. Example This shows a standard example that plots the solution at each time step. This code requires pyqt5 and matplotlib to function properly. \"\"\" Solve the second order equation x'' = -x x(0) = 0 x'(0) = 1 which has the solution x(t) = sin(t) \"\"\" import matplotlib.pyplot as plt import numpy as np from odeiter import TimeDomain_Start_Stop_MaxSpacing, RK4 u0 = np.array([0, 1]) A = np.array( [ [0, 1], [-1, 0], ] ) def rhs(t, u): return A @ u def exact(t): # exact solution for testing return np.sin(t) t0, tf = 0, 2 * np.pi max_time_step = 1e-2 # Create a TimeDomain object time = TimeDomain_Start_Stop_MaxSpacing(t0, tf, max_time_step) # Choose a solver solver = RK4() plt.ion() # requires pyqt5 for interactive plotting # Loop over the soluttion for t, u in zip(time.array, solver.solution_generator(u0, rhs, time)): # do whatever you want with the solution at each step x, y = u plt.plot(t, x, \"k.\") plt.pause(1e-3) plt.show(block=True)","title":"odeiter"},{"location":"#odeiter","text":"An iterator-based python package for solving systems of differential equations. For example, to solve the initial value problem $$ \\begin{align} u''(t) &= -u \\\\ u(0) &= 0 \\\\ u'(0) &= 1 \\end{align} $$ we can express it as a first-order system $$ \\begin{align} \\vec{u}' &= \\begin{bmatrix} 0 & 1 \\\\ -1 & 0 \\end{bmatrix} \\vec{u} \\\\ \\vec{u} &= \\begin{bmatrix}0 \\\\ 1 \\end{bmatrix} \\end{align} $$ then solve the system with a time-integrator like RK4 like so: >>> import numpy as np >>> from odeiter import TimeDomain, RK4 >>> u0 = np.array([0.0, 1.0]) >>> >>> def rhs(t, u): ... return np.array([[0, 1], [-1, 0]]) @ u ... >>> time = TimeDomain(0, 0.1, 4) >>> solver = RK4() >>> for u in solver.solution_generator(u0, rhs, time): ... # so something with the solution at this time ... print(u) ... [0. 1.] [0.09983333 0.99500417] [0.19866917 0.9800666 ] [0.29551996 0.95533654] [0.38941803 0.9210611 ]","title":"odeiter"},{"location":"#why-another-ode-solver","text":"The elephant in the room is scipy.integrate.sovle_ivp . Why would you use odeiter instead? If you want an array of your solution at all time points in a finite interval then solve_ivp is your best solution, but I found myself needing something more flexible. So I made odeiter which takes advantage of Python generators. Generators decouple the solver code from the looping body. In general, you don't want to simply compute the soltuion to your system. You want to compute the solution and do something with the solution. For example, the following animation was made using odeiter and it solves the system $$ x''(t) = -x, \\qquad x(0) = 0, \\qquad x'(0) = 1 $$ using 6 different solvers, simultaineously. At each time step it plots the solution, computes the relative erorr, and plots the relative error. This can be done with solve_ivp but one would have to store the entire solution for each solve in memory and then loop again to perform the plotting. That doesn't sound so bad for a system with only two variables (since it's a second order equation), but this becomes imensly important when you want to solve PDEs. For example, I used odeiter to solve a neuralfield eqution on a bumpy-sphere. A neural field equation is an integro-differential equation, so the resulting ODE had hundreds of thousands of dimensions, one for each sample point on the surface. At each time step, I plot the solution (left) and I also plot the maximum value of the solution (right) as a continuous path across the surface. Once a frame for the animation is generated, the solution at that time point is no longer requried so it is discarded and the memory is freed. Another advantage, is that generators are lazy. They don't compute the solution until you ask for it. This allows you to run simulations without a predetermined stoping condition. For example, the flowing animation shows two simulations created with odeiter where the difference is in the amplitudes of the forcing functions (magenta). The top simulation entrains so the solution (blue) rides the forcing function (magenta) indefinately, and achieves a stable traveling wave solution. In the bottom simulation, the solution rides the forcing function for a while but in the end it does not entrain because the forcing function is too weak. I tested many amplitudes and simulated until either they reached a traveling pulse solution or until the forcing term was separated from the solution by a certain distance. I was able to implement this simply without needing to know how long I would simulate.","title":"Why another ODE solver?"},{"location":"#example","text":"This shows a standard example that plots the solution at each time step. This code requires pyqt5 and matplotlib to function properly. \"\"\" Solve the second order equation x'' = -x x(0) = 0 x'(0) = 1 which has the solution x(t) = sin(t) \"\"\" import matplotlib.pyplot as plt import numpy as np from odeiter import TimeDomain_Start_Stop_MaxSpacing, RK4 u0 = np.array([0, 1]) A = np.array( [ [0, 1], [-1, 0], ] ) def rhs(t, u): return A @ u def exact(t): # exact solution for testing return np.sin(t) t0, tf = 0, 2 * np.pi max_time_step = 1e-2 # Create a TimeDomain object time = TimeDomain_Start_Stop_MaxSpacing(t0, tf, max_time_step) # Choose a solver solver = RK4() plt.ion() # requires pyqt5 for interactive plotting # Loop over the soluttion for t, u in zip(time.array, solver.solution_generator(u0, rhs, time)): # do whatever you want with the solution at each step x, y = u plt.plot(t, x, \"k.\") plt.pause(1e-3) plt.show(block=True)","title":"Example"},{"location":"reference/","text":"odeiter A module for solving systems of differential equations. Specifically inital value problems of the form u'(t) = rhs(t, u) u(0) = u0 To sovle this with odeiter you will need a discretized time domain from odeiter.time_domain and a solver that subclasses odeiter.time_integrator. from odeiter import TimeDomain, RK4 time = TimeDomain(0, 0.1, 10) # discretize the interval [0, 1] with 11 points solver = RK4() for u in solver.solution_generator(u0, rhs, time): # do something with the soluiton at each step print(u) A collection of time-discretizations required for odeiter solvers. TimeDomain A class representing the discretization of a temporal domain. This is used as an input to the odeiter.time_integrator.TimeInterator solvers. TimeDomain(start: float, spacing: float, steps: int) Represents a discretization of the time interval [start, spacing*steps] with steps+1 points including endpoints. t0 = 0 dt = 0.1 steps = 5 time = TimeDomain(t0, dt, steps) print(time.array) Source code in src/odeiter/time_domain.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class TimeDomain : \"\"\" A class representing the discretization of a temporal domain. This is used as an input to the odeiter.time_integrator.TimeInterator solvers. TimeDomain(start: float, spacing: float, steps: int) Represents a discretization of the time interval [start, spacing*steps] with steps+1 points including endpoints. >>>t0 = 0 >>>dt = 0.1 >>>steps = 5 >>>time = TimeDomain(t0, dt, steps) >>>print(time.array) \"\"\" def __init__ ( self , start : float , spacing : float , steps : int ): self . start = start self . spacing = spacing self . steps = steps self . initialze_array () def initialze_array ( self ): self . array = self . start + self . spacing * np . arange ( self . steps + 1 , dtype = float ) def __iter__ ( self ): yield from self . array TimeDomain_Start_Stop_MaxSpacing Bases: TimeDomain A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_MaxSpacing(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with stepsize less than max_spacing. Source code in src/odeiter/time_domain.py 36 37 38 39 40 41 42 43 44 45 46 47 48 class TimeDomain_Start_Stop_MaxSpacing ( TimeDomain ): \"\"\" A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_MaxSpacing(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with stepsize less than max_spacing. \"\"\" def __init__ ( self , start : float , stop : float , max_spacing : float ): self . start = start self . steps = math . ceil (( stop - start ) / max_spacing ) self . spacing = ( stop - start ) / self . steps self . initialze_array () TimeDomain_Start_Stop_Steps Bases: TimeDomain A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_Steps(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with steps equally sized steps. Source code in src/odeiter/time_domain.py 51 52 53 54 55 56 57 58 59 60 61 62 63 class TimeDomain_Start_Stop_Steps ( TimeDomain ): \"\"\" A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_Steps(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with `steps` equally sized steps. \"\"\" def __init__ ( self , start : float , stop : float , steps : int ): self . start = start self . steps = steps self . spacing = ( stop - start ) / steps self . initialze_array () TimeRay Bases: TimeDomain A variant of odeiter.Timedomain that has no end time. Only use this with odeiter.TimeIntegrator.solution_generator. This is effectively a while-loop, so always program a termination condition. Do not use this with odeiter.TimeIntegrator.solve or odeiter.TimeIntgegraor.t_final. Doing so will resut in an infinite loop. TimeRay(start: float, spacing: float) Discretizes the temporal interval [start, oo) with steps equally sized steps. This is useful for simulating a system into the future for an amount of time that is unkown from the start. For example, simulating until the difference between two solutions is above a threshold. Source code in src/odeiter/time_domain.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class TimeRay ( TimeDomain ): \"\"\" A variant of odeiter.Timedomain that has no end time. Only use this with odeiter.TimeIntegrator.solution_generator. This is effectively a while-loop, so always program a termination condition. Do not use this with odeiter.TimeIntegrator.solve or odeiter.TimeIntgegraor.t_final. Doing so will resut in an infinite loop. TimeRay(start: float, spacing: float) Discretizes the temporal interval [start, oo) with `steps` equally sized steps. This is useful for simulating a system into the future for an amount of time that is unkown from the start. For example, simulating until the difference between two solutions is above a threshold. \"\"\" def __init__ ( self , start : float , spacing : float ): self . start = start self . spacing = spacing @property def array ( self ): return Ray ( self . start , self . spacing ) def __iter__ ( self ): return self . array . __iter__ () A base class for solvers. For concrete classes see odeiter.adams_bashforth odeiter.adams_moulton odeiter.backward_differentiation odeiter.single_step If you're unsure what you're looking for, try odeiter.RK4 TimeIntegrator Bases: ABC Source code in src/odeiter/time_integrator.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class TimeIntegrator ( ABC ): @abstractproperty def name ( self ) -> str : ... @abstractproperty def order ( self ) -> int : \"\"\"The order of the method. If this method is order o then cutting the time-step in half should reduce the error by a factor of (1/2)^o. This is limited by machine precision. Additionally, it may not exhibit this convergence behaviour if the time step is too large, or if the forcing term is not smooth enough. \"\"\" ... @abstractmethod def solution_generator ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> Generator [ np . ndarray [ float ], None , None ]: \"\"\" Return a generator that yields the solution at each time in time.array. u0: a numpy array of initial conditions. It should have the same shape as the solution at each time step. rhs: A function rhs(t, u) that is the right-hand-side of the equation u' = rhs(t, u). time: An odeiter.TimeDomain instance. Returns: a generator that yeilds the solution at each time step in time.array. \"\"\" ... def solve ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Return a list of the solutions at each time for times in time.array. Equivalent to list(solver.solution_generator(u0, rhs, time)). See TimeIntegrator.solution_generator for parameter inputs. \"\"\" return list ( self . solution_generator ( u0 , rhs , time )) def t_final ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Returns the solution at the final time time.array[-1]. Equivalent to solver.solve[-1]. See TimeIntegrator.solution_generator for parameter inputs. \"\"\" for u in self . solution_generator ( u0 , rhs , time ): pass return u order () -> int The order of the method. If this method is order o then cutting the time-step in half should reduce the error by a factor of (1/2)^o. This is limited by machine precision. Additionally, it may not exhibit this convergence behaviour if the time step is too large, or if the forcing term is not smooth enough. Source code in src/odeiter/time_integrator.py 22 23 24 25 26 27 28 29 30 31 32 @abstractproperty def order ( self ) -> int : \"\"\"The order of the method. If this method is order o then cutting the time-step in half should reduce the error by a factor of (1/2)^o. This is limited by machine precision. Additionally, it may not exhibit this convergence behaviour if the time step is too large, or if the forcing term is not smooth enough. \"\"\" ... solution_generator ( u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain ) -> Generator [ np . ndarray [ float ], None , None ] abstractmethod Return a generator that yields the solution at each time in time.array. a numpy array of initial conditions. It should have the same shape as the solution at each time step. A function rhs(t, u) that is the right-hand-side of the equation u' = rhs(t, u). time: An odeiter.TimeDomain instance. Returns: a generator that yeilds the solution at each time step in time.array. Source code in src/odeiter/time_integrator.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @abstractmethod def solution_generator ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> Generator [ np . ndarray [ float ], None , None ]: \"\"\" Return a generator that yields the solution at each time in time.array. u0: a numpy array of initial conditions. It should have the same shape as the solution at each time step. rhs: A function rhs(t, u) that is the right-hand-side of the equation u' = rhs(t, u). time: An odeiter.TimeDomain instance. Returns: a generator that yeilds the solution at each time step in time.array. \"\"\" ... solve ( u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain ) -> list [ np . ndarray [ float ]] Return a list of the solutions at each time for times in time.array. Equivalent to list(solver.solution_generator(u0, rhs, time)). See TimeIntegrator.solution_generator for parameter inputs. Source code in src/odeiter/time_integrator.py 57 58 59 60 61 62 63 64 65 66 67 68 def solve ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Return a list of the solutions at each time for times in time.array. Equivalent to list(solver.solution_generator(u0, rhs, time)). See TimeIntegrator.solution_generator for parameter inputs. \"\"\" return list ( self . solution_generator ( u0 , rhs , time )) t_final ( u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain ) -> list [ np . ndarray [ float ]] Returns the solution at the final time time.array[-1]. Equivalent to solver.solve[-1]. See TimeIntegrator.solution_generator for parameter inputs. Source code in src/odeiter/time_integrator.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def t_final ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Returns the solution at the final time time.array[-1]. Equivalent to solver.solve[-1]. See TimeIntegrator.solution_generator for parameter inputs. \"\"\" for u in self . solution_generator ( u0 , rhs , time ): pass return u A collection of single-step solvers.","title":"reference"},{"location":"reference/#odeiter_1","text":"A module for solving systems of differential equations. Specifically inital value problems of the form u'(t) = rhs(t, u) u(0) = u0 To sovle this with odeiter you will need a discretized time domain from odeiter.time_domain and a solver that subclasses odeiter.time_integrator. from odeiter import TimeDomain, RK4 time = TimeDomain(0, 0.1, 10) # discretize the interval [0, 1] with 11 points solver = RK4() for u in solver.solution_generator(u0, rhs, time): # do something with the soluiton at each step print(u) A collection of time-discretizations required for odeiter solvers.","title":"odeiter"},{"location":"reference/#odeiter.time_domain.TimeDomain","text":"A class representing the discretization of a temporal domain. This is used as an input to the odeiter.time_integrator.TimeInterator solvers. TimeDomain(start: float, spacing: float, steps: int) Represents a discretization of the time interval [start, spacing*steps] with steps+1 points including endpoints. t0 = 0 dt = 0.1 steps = 5 time = TimeDomain(t0, dt, steps) print(time.array) Source code in src/odeiter/time_domain.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class TimeDomain : \"\"\" A class representing the discretization of a temporal domain. This is used as an input to the odeiter.time_integrator.TimeInterator solvers. TimeDomain(start: float, spacing: float, steps: int) Represents a discretization of the time interval [start, spacing*steps] with steps+1 points including endpoints. >>>t0 = 0 >>>dt = 0.1 >>>steps = 5 >>>time = TimeDomain(t0, dt, steps) >>>print(time.array) \"\"\" def __init__ ( self , start : float , spacing : float , steps : int ): self . start = start self . spacing = spacing self . steps = steps self . initialze_array () def initialze_array ( self ): self . array = self . start + self . spacing * np . arange ( self . steps + 1 , dtype = float ) def __iter__ ( self ): yield from self . array","title":"TimeDomain"},{"location":"reference/#odeiter.time_domain.TimeDomain_Start_Stop_MaxSpacing","text":"Bases: TimeDomain A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_MaxSpacing(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with stepsize less than max_spacing. Source code in src/odeiter/time_domain.py 36 37 38 39 40 41 42 43 44 45 46 47 48 class TimeDomain_Start_Stop_MaxSpacing ( TimeDomain ): \"\"\" A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_MaxSpacing(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with stepsize less than max_spacing. \"\"\" def __init__ ( self , start : float , stop : float , max_spacing : float ): self . start = start self . steps = math . ceil (( stop - start ) / max_spacing ) self . spacing = ( stop - start ) / self . steps self . initialze_array ()","title":"TimeDomain_Start_Stop_MaxSpacing"},{"location":"reference/#odeiter.time_domain.TimeDomain_Start_Stop_Steps","text":"Bases: TimeDomain A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_Steps(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with steps equally sized steps. Source code in src/odeiter/time_domain.py 51 52 53 54 55 56 57 58 59 60 61 62 63 class TimeDomain_Start_Stop_Steps ( TimeDomain ): \"\"\" A variant of odeiter.Timedomain that accepts different parameters. TimeDomain_Start_Stop_Steps(start: float, stop: float, max_spacing: int) Discretizes the temporal interval [start, stop] with `steps` equally sized steps. \"\"\" def __init__ ( self , start : float , stop : float , steps : int ): self . start = start self . steps = steps self . spacing = ( stop - start ) / steps self . initialze_array ()","title":"TimeDomain_Start_Stop_Steps"},{"location":"reference/#odeiter.time_domain.TimeRay","text":"Bases: TimeDomain A variant of odeiter.Timedomain that has no end time. Only use this with odeiter.TimeIntegrator.solution_generator. This is effectively a while-loop, so always program a termination condition. Do not use this with odeiter.TimeIntegrator.solve or odeiter.TimeIntgegraor.t_final. Doing so will resut in an infinite loop. TimeRay(start: float, spacing: float) Discretizes the temporal interval [start, oo) with steps equally sized steps. This is useful for simulating a system into the future for an amount of time that is unkown from the start. For example, simulating until the difference between two solutions is above a threshold. Source code in src/odeiter/time_domain.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 class TimeRay ( TimeDomain ): \"\"\" A variant of odeiter.Timedomain that has no end time. Only use this with odeiter.TimeIntegrator.solution_generator. This is effectively a while-loop, so always program a termination condition. Do not use this with odeiter.TimeIntegrator.solve or odeiter.TimeIntgegraor.t_final. Doing so will resut in an infinite loop. TimeRay(start: float, spacing: float) Discretizes the temporal interval [start, oo) with `steps` equally sized steps. This is useful for simulating a system into the future for an amount of time that is unkown from the start. For example, simulating until the difference between two solutions is above a threshold. \"\"\" def __init__ ( self , start : float , spacing : float ): self . start = start self . spacing = spacing @property def array ( self ): return Ray ( self . start , self . spacing ) def __iter__ ( self ): return self . array . __iter__ () A base class for solvers. For concrete classes see odeiter.adams_bashforth odeiter.adams_moulton odeiter.backward_differentiation odeiter.single_step If you're unsure what you're looking for, try odeiter.RK4","title":"TimeRay"},{"location":"reference/#odeiter.time_integrator.TimeIntegrator","text":"Bases: ABC Source code in src/odeiter/time_integrator.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class TimeIntegrator ( ABC ): @abstractproperty def name ( self ) -> str : ... @abstractproperty def order ( self ) -> int : \"\"\"The order of the method. If this method is order o then cutting the time-step in half should reduce the error by a factor of (1/2)^o. This is limited by machine precision. Additionally, it may not exhibit this convergence behaviour if the time step is too large, or if the forcing term is not smooth enough. \"\"\" ... @abstractmethod def solution_generator ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> Generator [ np . ndarray [ float ], None , None ]: \"\"\" Return a generator that yields the solution at each time in time.array. u0: a numpy array of initial conditions. It should have the same shape as the solution at each time step. rhs: A function rhs(t, u) that is the right-hand-side of the equation u' = rhs(t, u). time: An odeiter.TimeDomain instance. Returns: a generator that yeilds the solution at each time step in time.array. \"\"\" ... def solve ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Return a list of the solutions at each time for times in time.array. Equivalent to list(solver.solution_generator(u0, rhs, time)). See TimeIntegrator.solution_generator for parameter inputs. \"\"\" return list ( self . solution_generator ( u0 , rhs , time )) def t_final ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Returns the solution at the final time time.array[-1]. Equivalent to solver.solve[-1]. See TimeIntegrator.solution_generator for parameter inputs. \"\"\" for u in self . solution_generator ( u0 , rhs , time ): pass return u","title":"TimeIntegrator"},{"location":"reference/#odeiter.time_integrator.TimeIntegrator.order","text":"The order of the method. If this method is order o then cutting the time-step in half should reduce the error by a factor of (1/2)^o. This is limited by machine precision. Additionally, it may not exhibit this convergence behaviour if the time step is too large, or if the forcing term is not smooth enough. Source code in src/odeiter/time_integrator.py 22 23 24 25 26 27 28 29 30 31 32 @abstractproperty def order ( self ) -> int : \"\"\"The order of the method. If this method is order o then cutting the time-step in half should reduce the error by a factor of (1/2)^o. This is limited by machine precision. Additionally, it may not exhibit this convergence behaviour if the time step is too large, or if the forcing term is not smooth enough. \"\"\" ...","title":"order"},{"location":"reference/#odeiter.time_integrator.TimeIntegrator.solution_generator","text":"Return a generator that yields the solution at each time in time.array. a numpy array of initial conditions. It should have the same shape as the solution at each time step. A function rhs(t, u) that is the right-hand-side of the equation u' = rhs(t, u). time: An odeiter.TimeDomain instance. Returns: a generator that yeilds the solution at each time step in time.array. Source code in src/odeiter/time_integrator.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @abstractmethod def solution_generator ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> Generator [ np . ndarray [ float ], None , None ]: \"\"\" Return a generator that yields the solution at each time in time.array. u0: a numpy array of initial conditions. It should have the same shape as the solution at each time step. rhs: A function rhs(t, u) that is the right-hand-side of the equation u' = rhs(t, u). time: An odeiter.TimeDomain instance. Returns: a generator that yeilds the solution at each time step in time.array. \"\"\" ...","title":"solution_generator"},{"location":"reference/#odeiter.time_integrator.TimeIntegrator.solve","text":"Return a list of the solutions at each time for times in time.array. Equivalent to list(solver.solution_generator(u0, rhs, time)). See TimeIntegrator.solution_generator for parameter inputs. Source code in src/odeiter/time_integrator.py 57 58 59 60 61 62 63 64 65 66 67 68 def solve ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Return a list of the solutions at each time for times in time.array. Equivalent to list(solver.solution_generator(u0, rhs, time)). See TimeIntegrator.solution_generator for parameter inputs. \"\"\" return list ( self . solution_generator ( u0 , rhs , time ))","title":"solve"},{"location":"reference/#odeiter.time_integrator.TimeIntegrator.t_final","text":"Returns the solution at the final time time.array[-1]. Equivalent to solver.solve[-1]. See TimeIntegrator.solution_generator for parameter inputs. Source code in src/odeiter/time_integrator.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def t_final ( self , u0 : np . ndarray [ float ], rhs : Callable [[ float , np . ndarray [ float ]], np . ndarray [ float ]], time : TimeDomain , ) -> list [ np . ndarray [ float ]]: \"\"\" Returns the solution at the final time time.array[-1]. Equivalent to solver.solve[-1]. See TimeIntegrator.solution_generator for parameter inputs. \"\"\" for u in self . solution_generator ( u0 , rhs , time ): pass return u A collection of single-step solvers.","title":"t_final"}]}