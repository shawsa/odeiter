{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"odeiter","text":"<p>An iterator-based  python package for solving systems of differential equations.</p>"},{"location":"#why-another-ode-solver","title":"Why another ODE solver?","text":"<p>The elephant in the room is <code>scipy.integrate.sovle_ivp</code>. Why would you use <code>odeiter</code> instead? If you want an array of your solution at all time points in a finite interval then <code>solve_ivp</code> is your best solution, but I found myself needing something more flexible. So I made <code>odeiter</code> which takes advantage of Python generators.</p> <p>Generators decouple the solver code from the looping body. In general, you don't want to simply compute the soltuion to your system. You want to compute the solution and do something with the solution. For example, the following animation was made using <code>odeiter</code> and it solves the system $$ x''(t) = -x, \\qquad x(0) = 0, \\qquad x'(0) = 1 $$ using 6 different solvers, simultaineously. At each time step it plots the solution, computes the relative erorr, and plots the relative error. </p> <p>This can be done with <code>solve_ivp</code> but one would have to store the entire solution for each solve in memory and then loop again to perform the plotting. That doesn't sound so bad for a system with only two variables (since it's a second order equation), but this becomes imensly important when you want to solve PDEs where the number of dimensions can easily be in the thousands or millions.</p>"},{"location":"#memory-efficient","title":"Memory Efficient","text":"<p>For example, I used <code>odeiter</code> to solve a neuralfield eqution on a bumpy-sphere. A neural field equation is an integro-differential equation, so the resulting ODE had hundreds of thousands of dimensions, one for each sample point on the surface. At each time step, I plot the solution (left) and I also plot the maximum value of the solution (right) as a continuous path across the surface.</p> <p></p> <p>Once a frame for the animation is generated, the solution at that time point is no longer requried so it is discarded and the memory is reclaimed. </p>"},{"location":"#lazy","title":"Lazy","text":"<p>Another advantage, is that generators are lazy. They don't compute the solution until you ask for it. This allows you to run simulations without a predetermined stoping condition. For example, the flowing animation shows two simulations created with <code>odeiter</code> where the difference is in the amplitudes of the forcing functions (magenta).</p> <p></p> <p>The top simulation entrains so the solution (blue) rides the forcing function (magenta) indefinitely, and achieves a stable traveling wave solution. In the bottom simulation, the solution rides the forcing function for a while but in the end it does not entrain because the forcing function is too weak. I tested many amplitudes and simulated until either they reached a traveling pulse solution or until the forcing term was separated from the solution by a certain distance. I was able to implement this easily without needing to know how long the simulation would need to run.</p>"},{"location":"basic_examples/","title":"Basic Examples","text":""},{"location":"basic_examples/#basic-syntax","title":"Basic syntax","text":"<p>For example, to solve the initial value problem $$ \\begin{align}     u''(t) &amp;= -u \\\\     u(0) &amp;= 0 \\\\     u'(0) &amp;= 1 \\end{align} $$ we can express it as a first-order system $$ \\begin{align}     \\vec{u}' &amp;= \\begin{bmatrix} 0 &amp; 1 \\\\ -1 &amp; 0 \\end{bmatrix} \\vec{u} \\\\     \\vec{u} &amp;= \\begin{bmatrix}0 \\\\ 1 \\end{bmatrix} \\end{align} $$ then solve the system with a time-integrator like RK4 like so:</p> <pre><code>import numpy as np\nfrom odeiter import TimeDomain, RK4\nu0 = np.array([0.0, 1.0])\n\ndef rhs(t, u):\n    return np.array([[0, 1], [-1, 0]]) @ u\n\ntime = TimeDomain(0, 0.1, 4)\nsolver = RK4()\nfor u in solver.solution_generator(u0, rhs, time):\n    # so something with the solution at this time\n    print(u)\n\n# OUTPUT\n# [0. 1.]\n# [0.09983333 0.99500417]\n# [0.19866917 0.9800666 ]\n# [0.29551996 0.95533654]\n# [0.38941803 0.9210611 ]\n</code></pre>"},{"location":"basic_examples/#interactive-plotting","title":"Interactive Plotting","text":"<p>This shows some of the flexibily by solving the system above, plotting the solution and plotting the error.</p> <p>The plotting occurs as the system is solved, rather than after it is solved and requires <code>pyqt5</code> and <code>matplotlib</code> to function properly.</p> <pre><code>\"\"\"\nSolve the second order equation\nx'' = -x\nx(0) = 0\nx'(0) = 1\n\nwhich has the solution\nx(t) = sin(t)\n\"\"\"\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom odeiter import TimeDomain_Start_Stop_MaxSpacing, RK4\n\nx0 = 0\ny0 = 1\nA = np.array(\n    [\n        [0, 1],\n        [-1, 0],\n    ]\n)\nu0 = np.array([x0, y0])\n\n\ndef rhs(t, u):\n    return A @ u\n\n\ndef exact(t):  # exact solution for testing\n    return np.sin(t)\n\n\nt0, tf = 0, 2 * np.pi\nmax_time_step = 1e-2\n# Create a TimeDomain object\ntime = TimeDomain_Start_Stop_MaxSpacing(t0, tf, max_time_step)\n# Choose a solver\nsolver = RK4()\nplt.ion()  # requires pyqt5 for interactive plotting\nfor t, u in zip(time.array, solver.solution_generator(u0, rhs, time)):\n    # do whatever you want with the solution\n    x, y = u\n    plt.plot(t, x, \"k.\")\n    plt.pause(1e-3)\nplt.show(block=True)\n</code></pre>"},{"location":"install/","title":"Installing from github","text":"<p>The sourcecode can be found at www.github.com/shawsa/odeiter and the project can be installed directly from github with <pre><code>pip install git+https://github.com/shawsa/odeiter.git\n</code></pre></p>"},{"location":"reference/adams_bashforth/","title":"adams_bashforth","text":"<p>Adams-Bashforth solvers are a family of explicit solvers that perform a single right-hand-side evaluation per time step and achieve high-order accuracy by storing the derivative at several previous time steps. This makes them computationally efficent at the cost of some memory.</p> <p>Adams-Bashforth methods are mult-step solvers and thus require not only an initial condition, but also the solution at the first few time points dependeing on the order of the method. For example, AB3 requires the solution at times \\(t_0, t_0+k, t_0+2k\\) where \\(t_0\\) is the inital time and \\(k\\) is the temporal step-size.</p> <p>This implementation assumes that you only have the solution at \\(t_0\\) and accepts another time-integrator as a seed. For example, we may use RK4 (a single step method). You must also decide the step-size of the single-step method such that the step-size of the Adams-Bashfort solver is an integer multiple.</p> <p>For example, <pre><code>    solver = AB5(RK4(), seed_steps_per_step=2)\n</code></pre> Will use the initial condition and RK4 to take 8 time times steps each at half the step size. This will generate solutions at times \\(t_0, t_0 + k/2, t_0 + k, t0+ 3k/2, ..., t_0 + 4k\\). It will then subsample these as necessary to use as appropriate seed steps.</p> <p>It is important to ensure that the order of the seed method and the number of seed steps per step are at least as accurate as the orer of the Adams-Bashforth method. For example <pre><code>solver = AB5(RK4(), seed_steps_per_step=1)\n</code></pre> would not give a fifth order method because RK4 will generate seed steps up to fourth order accuracy. In contrast <pre><code>solver = AB5(RK4(), seed_steps_per_step=2)\n</code></pre> will generate seed steps to eighth order accuracy, relative to the step size of the Adams-Bashfort solver.</p>"},{"location":"reference/adams_bashforth/#adams_bashforth","title":"adams_bashforth","text":"<p>A module containing Adams-Bashforth solvers of several orders.</p>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract","title":"<code>AdamsBashforthAbstract</code>","text":"<p>               Bases: <code>TimeIntegrator</code></p> <p>An abstract class for Adams-Bashforth (AB) solvers. All AB solvers will inherit these methods.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>class AdamsBashforthAbstract(TimeIntegrator):\n    \"\"\"\n    An abstract class for Adams-Bashforth (AB) solvers.\n    All AB solvers will inherit these methods.\n    \"\"\"\n\n    def __init__(self, seed: TimeIntegrator, seed_steps_per_step: int):\n        \"\"\"\n        Parameters:\n            seed: another time integrator used to take the first few steps.\n            seed_steps_per_step: the number of seed steps taking per step\n                of the AB integrator.\n        \"\"\"\n        self.seed = seed\n        self.seed_steps_per_step = seed_steps_per_step\n        self.seed_steps = self.order - 1\n\n    @abstractproperty\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            The name of the method\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def order(self) -&gt; int:\n        \"\"\"\n        Returns:\n            The order of the method\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def fs_coeffs(self) -&gt; list[float]:\n        \"\"\"\n        Returns:\n            The interpolation coefficients of the method.\n        \"\"\"\n        ...\n\n    def update(\n        self, u: np.ndarray[float], fs: np.ndarray[float], delta_t: float\n    ) -&gt; np.ndarray[float]:\n        \"\"\"\n        Compute the next time step. You probably want `solution_generator` instead.\n\n        Parameters:\n            u: The solution at the current time-step.\n            fs: the right-hand-side at several previous time-steps.\n            delta_t: the temporal step-size.\n\n        Returns:\n            The solution at the next time step.\n        \"\"\"\n        return u + delta_t * sum(c * f for c, f in zip(self.fs_coeffs[::-1], fs))\n\n    def solution_generator(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; Generator[np.ndarray[float], None, None]:\n        \"\"\"Create a generator that yields the solution for each time in `time`.\n\n        Parameters:\n            u0: The initial condition of the system.\n                Must be the same size as the system.\n            rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n            time: The discretized time domain from.\n\n        Returns:\n            A generator that yields the solution at each time in `time.array`.\n        \"\"\"\n        seed_steps = self.order - 1\n        seed_time = TimeRay(\n            time.start,\n            time.spacing / self.seed_steps_per_step,\n        )\n        t = time.start\n        fs = deque(maxlen=self.order)\n        for u in islice(\n            self.seed.solution_generator(u0, rhs, seed_time),\n            0,\n            self.seed_steps_per_step * seed_steps + 1,\n            self.seed_steps_per_step,\n        ):\n            yield u\n            fs.append(rhs(t, u))\n            t += time.spacing\n\n        for t in time.array[seed_steps:-1]:\n            u = self.update(u, fs, time.spacing)\n            yield u\n            fs.append(rhs(t + time.spacing, u))\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract.__init__","title":"<code>__init__(seed, seed_steps_per_step)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>seed</code> <code>TimeIntegrator</code> <p>another time integrator used to take the first few steps.</p> required <code>seed_steps_per_step</code> <code>int</code> <p>the number of seed steps taking per step of the AB integrator.</p> required Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>def __init__(self, seed: TimeIntegrator, seed_steps_per_step: int):\n    \"\"\"\n    Parameters:\n        seed: another time integrator used to take the first few steps.\n        seed_steps_per_step: the number of seed steps taking per step\n            of the AB integrator.\n    \"\"\"\n    self.seed = seed\n    self.seed_steps_per_step = seed_steps_per_step\n    self.seed_steps = self.order - 1\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract.name","title":"<code>name()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The name of the method</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>@abstractproperty\ndef name(self) -&gt; str:\n    \"\"\"\n    Returns:\n        The name of the method\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract.order","title":"<code>order()</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The order of the method</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>@abstractproperty\ndef order(self) -&gt; int:\n    \"\"\"\n    Returns:\n        The order of the method\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract.fs_coeffs","title":"<code>fs_coeffs()</code>","text":"<p>Returns:</p> Type Description <code>list[float]</code> <p>The interpolation coefficients of the method.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>@abstractproperty\ndef fs_coeffs(self) -&gt; list[float]:\n    \"\"\"\n    Returns:\n        The interpolation coefficients of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract.update","title":"<code>update(u, fs, delta_t)</code>","text":"<p>Compute the next time step. You probably want <code>solution_generator</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>u</code> <code>ndarray[float]</code> <p>The solution at the current time-step.</p> required <code>fs</code> <code>ndarray[float]</code> <p>the right-hand-side at several previous time-steps.</p> required <code>delta_t</code> <code>float</code> <p>the temporal step-size.</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>The solution at the next time step.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>def update(\n    self, u: np.ndarray[float], fs: np.ndarray[float], delta_t: float\n) -&gt; np.ndarray[float]:\n    \"\"\"\n    Compute the next time step. You probably want `solution_generator` instead.\n\n    Parameters:\n        u: The solution at the current time-step.\n        fs: the right-hand-side at several previous time-steps.\n        delta_t: the temporal step-size.\n\n    Returns:\n        The solution at the next time step.\n    \"\"\"\n    return u + delta_t * sum(c * f for c, f in zip(self.fs_coeffs[::-1], fs))\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AdamsBashforthAbstract.solution_generator","title":"<code>solution_generator(u0, rhs, time)</code>","text":"<p>Create a generator that yields the solution for each time in <code>time</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>The initial condition of the system. Must be the same size as the system.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>The right-hand-side as a function with signature <code>rhs(t, u) -&gt; u'</code>.</p> required <code>time</code> <code>TimeDomain</code> <p>The discretized time domain from.</p> required <p>Returns:</p> Type Description <code>None</code> <p>A generator that yields the solution at each time in <code>time.array</code>.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>def solution_generator(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; Generator[np.ndarray[float], None, None]:\n    \"\"\"Create a generator that yields the solution for each time in `time`.\n\n    Parameters:\n        u0: The initial condition of the system.\n            Must be the same size as the system.\n        rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n        time: The discretized time domain from.\n\n    Returns:\n        A generator that yields the solution at each time in `time.array`.\n    \"\"\"\n    seed_steps = self.order - 1\n    seed_time = TimeRay(\n        time.start,\n        time.spacing / self.seed_steps_per_step,\n    )\n    t = time.start\n    fs = deque(maxlen=self.order)\n    for u in islice(\n        self.seed.solution_generator(u0, rhs, seed_time),\n        0,\n        self.seed_steps_per_step * seed_steps + 1,\n        self.seed_steps_per_step,\n    ):\n        yield u\n        fs.append(rhs(t, u))\n        t += time.spacing\n\n    for t in time.array[seed_steps:-1]:\n        u = self.update(u, fs, time.spacing)\n        yield u\n        fs.append(rhs(t + time.spacing, u))\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AB2","title":"<code>AB2</code>","text":"<p>               Bases: <code>AdamsBashforthAbstract</code></p> <p>Adams-Bashforth 2.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>class AB2(AdamsBashforthAbstract):\n    \"\"\"Adams-Bashforth 2.\"\"\"\n\n    @property\n    def order(self):\n        return 2\n\n    @property\n    def name(self):\n        return f\"AB2 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [3 / 2, -1 / 2]\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AB3","title":"<code>AB3</code>","text":"<p>               Bases: <code>AdamsBashforthAbstract</code></p> <p>Adams-Bashforth 3.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>class AB3(AdamsBashforthAbstract):\n    \"\"\"Adams-Bashforth 3.\"\"\"\n\n    @property\n    def order(self):\n        return 3\n\n    @property\n    def name(self):\n        return f\"AB3 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [23 / 12, -16 / 12, 5 / 12]\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AB4","title":"<code>AB4</code>","text":"<p>               Bases: <code>AdamsBashforthAbstract</code></p> <p>Adams-Bashforth 4.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>class AB4(AdamsBashforthAbstract):\n    \"\"\"Adams-Bashforth 4.\"\"\"\n\n    @property\n    def order(self):\n        return 4\n\n    @property\n    def name(self):\n        return f\"AB4 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [55 / 24, -59 / 24, 37 / 24, -9 / 24]\n</code></pre>"},{"location":"reference/adams_bashforth/#odeiter.adams_bashforth.AB5","title":"<code>AB5</code>","text":"<p>               Bases: <code>AdamsBashforthAbstract</code></p> <p>Adams-Bashforth 5.</p> Source code in <code>src/odeiter/adams_bashforth.py</code> <pre><code>class AB5(AdamsBashforthAbstract):\n    \"\"\"Adams-Bashforth 5.\"\"\"\n\n    @property\n    def order(self):\n        return 5\n\n    @property\n    def name(self):\n        return f\"AB5 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [1901 / 720, -2774 / 720, 2616 / 720, -1274 / 720, 251 / 720]\n</code></pre>"},{"location":"reference/adams_moulton/","title":"adams_moulton","text":"<p>Adams-Moulton solvers are a family of implicit solvers that perform a single right-hand-side solve per time step and achieve high-order accuracy by storing the derivative at several previous time steps.</p> <p>Adams-Moulton methods are mult-step solvers and thus require not only an initial condition, but also the solution at the first few time points dependeing on the order of the method. For example, AM3 requires the solution at times \\(t_0, t_0+k, t_0+2k\\) where \\(t_0\\) is the inital time and \\(k\\) is the temporal step-size.</p> <p>This implementation assumes that you only have the solution at \\(t_0\\) and accepts another time-integrator as a seed. For example, we may use RK4 (a single step method). You must also decide the step-size of the single-step method such that the step-size of the Adams-Moulton solver is an integer multiple.</p> <p>For example, <pre><code>    solver = AM4(RK4(), seed_steps_per_step=2)\n</code></pre> Will use the initial condition and RK4 to take 8 time times steps each at half the step size. This will generate solutions at times \\(t_0, t_0 + k/2, t_0 + k, t0 + 3k/2, ..., t_0 + 4k\\). It will then subsample these as necessary to use as appropriate seed steps.</p> <p>It is important to ensure that the order of the seed method and the number of seed steps per step are at least as accurate as the orer of the Adams-Moulton method. For example <pre><code>solver = AM4(RK4(), seed_steps_per_step=1)\n</code></pre> would not give a fifth order method because RK4 will generate seed steps up to fourth order accuracy. In contrast <pre><code>solver = AM5(RK4(), seed_steps_per_step=2)\n</code></pre> will generate seed steps to eighth order accuracy, relative to the step size of the Adams-Moulton solver.</p>"},{"location":"reference/adams_moulton/#adams_moulton","title":"adams_moulton","text":"<p>A module containing Adams-Moulton solvers of several orders.</p>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract","title":"<code>AdamsMoultonAbstract</code>","text":"<p>               Bases: <code>TimeIntegrator</code></p> <p>An abstract class for Adams-Moulton (AM) solvers. All AM solvers will inherit these methods. Additionally, they inherit the methods of <code>time_integrator.TimeIntegrator</code> as well.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>class AdamsMoultonAbstract(TimeIntegrator):\n    \"\"\"\n    An abstract class for Adams-Moulton (AM) solvers.\n    All AM solvers will inherit these methods. Additionally,\n    they inherit the methods of [`time_integrator.TimeIntegrator`](time_integrator.md)\n    as well.\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: TimeIntegrator,\n        seed_steps_per_step: int,\n        root_finder: RootFinder = DefaultRootFinder,\n    ):\n        \"\"\"\n        Parameters:\n            seed: another time integrator used to take the first few steps.\n            seed_steps_per_step: the number of seed steps taking per step\n                of the AB integrator.\n            root_finder: a function of the form `root_finder(f, u0)` that returns\n                the solution to `f(u) = 0` using `u0` as an approximate soluiton.\n        \"\"\"\n        self.seed = seed\n        self.seed_steps_per_step = seed_steps_per_step\n        self.seed_steps = self.order - 2\n        self.root_finder = root_finder.solve\n\n    @abstractproperty\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            The name of the method\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def order(self) -&gt; int:\n        \"\"\"\n        Returns:\n            The order of the method\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def fs_coeffs(self) -&gt; list[float]:\n        \"\"\"\n        Returns:\n            The interpolation coefficients of the method.\n        \"\"\"\n        ...\n\n    def update(\n        self,\n        t: float,\n        u: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        fs: np.ndarray[float],\n        delta_t: float,\n    ) -&gt; np.ndarray[float]:\n        \"\"\"\n        Compute the next time step. You probably want `solution_generator` instead.\n\n        Parameters:\n            t: The current time.\n            u: The solution at the current time-step.\n            rhs: The right-hand-side of the system as a function `rhs(t, u) -&gt; u'`.\n            fs: the right-hand-side at several previous time-steps.\n            delta_t: the temporal step-size.\n\n        Returns:\n            The solution at the next time step.\n        \"\"\"\n        const_vec = u + delta_t * sum(\n            c * f for c, f in zip(self.fs_coeffs[-1:0:-1], fs)\n        )\n\n        def func(x):\n            return -x + const_vec + delta_t * self.fs_coeffs[0] * rhs(t + delta_t, x)\n\n        return self.root_finder(func, u)\n\n    def solution_generator(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; Generator[np.ndarray[float], None, None]:\n        \"\"\"Create a generator that yields the solution for each time in `time`.\n\n        Parameters:\n            u0: The initial condition of the system.\n                Must be the same size as the system.\n            rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n            time: The discretized time domain from.\n\n        Returns:\n            A generator that yields the solution at each time in `time.array`.\n        \"\"\"\n        seed_steps = self.order - 1\n        seed_time = TimeRay(\n            time.start,\n            time.spacing / self.seed_steps_per_step,\n        )\n        t = time.start\n        fs = deque(maxlen=self.order - 1)\n        for u in islice(\n            self.seed.solution_generator(u0, rhs, seed_time),\n            0,\n            self.seed_steps_per_step * seed_steps + 1,\n            self.seed_steps_per_step,\n        ):\n            yield u\n            fs.append(rhs(t, u))\n            t += time.spacing\n\n        for t in time.array[seed_steps:-1]:\n            u = self.update(t, u, rhs, fs, time.spacing)\n            yield u\n            fs.append(rhs(t + time.spacing, u))\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract.__init__","title":"<code>__init__(seed, seed_steps_per_step, root_finder=DefaultRootFinder)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>seed</code> <code>TimeIntegrator</code> <p>another time integrator used to take the first few steps.</p> required <code>seed_steps_per_step</code> <code>int</code> <p>the number of seed steps taking per step of the AB integrator.</p> required <code>root_finder</code> <code>RootFinder</code> <p>a function of the form <code>root_finder(f, u0)</code> that returns the solution to <code>f(u) = 0</code> using <code>u0</code> as an approximate soluiton.</p> <code>DefaultRootFinder</code> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>def __init__(\n    self,\n    seed: TimeIntegrator,\n    seed_steps_per_step: int,\n    root_finder: RootFinder = DefaultRootFinder,\n):\n    \"\"\"\n    Parameters:\n        seed: another time integrator used to take the first few steps.\n        seed_steps_per_step: the number of seed steps taking per step\n            of the AB integrator.\n        root_finder: a function of the form `root_finder(f, u0)` that returns\n            the solution to `f(u) = 0` using `u0` as an approximate soluiton.\n    \"\"\"\n    self.seed = seed\n    self.seed_steps_per_step = seed_steps_per_step\n    self.seed_steps = self.order - 2\n    self.root_finder = root_finder.solve\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract.name","title":"<code>name()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The name of the method</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>@abstractproperty\ndef name(self) -&gt; str:\n    \"\"\"\n    Returns:\n        The name of the method\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract.order","title":"<code>order()</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The order of the method</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>@abstractproperty\ndef order(self) -&gt; int:\n    \"\"\"\n    Returns:\n        The order of the method\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract.fs_coeffs","title":"<code>fs_coeffs()</code>","text":"<p>Returns:</p> Type Description <code>list[float]</code> <p>The interpolation coefficients of the method.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>@abstractproperty\ndef fs_coeffs(self) -&gt; list[float]:\n    \"\"\"\n    Returns:\n        The interpolation coefficients of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract.update","title":"<code>update(t, u, rhs, fs, delta_t)</code>","text":"<p>Compute the next time step. You probably want <code>solution_generator</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>The current time.</p> required <code>u</code> <code>ndarray[float]</code> <p>The solution at the current time-step.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>The right-hand-side of the system as a function <code>rhs(t, u) -&gt; u'</code>.</p> required <code>fs</code> <code>ndarray[float]</code> <p>the right-hand-side at several previous time-steps.</p> required <code>delta_t</code> <code>float</code> <p>the temporal step-size.</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>The solution at the next time step.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>def update(\n    self,\n    t: float,\n    u: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    fs: np.ndarray[float],\n    delta_t: float,\n) -&gt; np.ndarray[float]:\n    \"\"\"\n    Compute the next time step. You probably want `solution_generator` instead.\n\n    Parameters:\n        t: The current time.\n        u: The solution at the current time-step.\n        rhs: The right-hand-side of the system as a function `rhs(t, u) -&gt; u'`.\n        fs: the right-hand-side at several previous time-steps.\n        delta_t: the temporal step-size.\n\n    Returns:\n        The solution at the next time step.\n    \"\"\"\n    const_vec = u + delta_t * sum(\n        c * f for c, f in zip(self.fs_coeffs[-1:0:-1], fs)\n    )\n\n    def func(x):\n        return -x + const_vec + delta_t * self.fs_coeffs[0] * rhs(t + delta_t, x)\n\n    return self.root_finder(func, u)\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AdamsMoultonAbstract.solution_generator","title":"<code>solution_generator(u0, rhs, time)</code>","text":"<p>Create a generator that yields the solution for each time in <code>time</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>The initial condition of the system. Must be the same size as the system.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>The right-hand-side as a function with signature <code>rhs(t, u) -&gt; u'</code>.</p> required <code>time</code> <code>TimeDomain</code> <p>The discretized time domain from.</p> required <p>Returns:</p> Type Description <code>None</code> <p>A generator that yields the solution at each time in <code>time.array</code>.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>def solution_generator(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; Generator[np.ndarray[float], None, None]:\n    \"\"\"Create a generator that yields the solution for each time in `time`.\n\n    Parameters:\n        u0: The initial condition of the system.\n            Must be the same size as the system.\n        rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n        time: The discretized time domain from.\n\n    Returns:\n        A generator that yields the solution at each time in `time.array`.\n    \"\"\"\n    seed_steps = self.order - 1\n    seed_time = TimeRay(\n        time.start,\n        time.spacing / self.seed_steps_per_step,\n    )\n    t = time.start\n    fs = deque(maxlen=self.order - 1)\n    for u in islice(\n        self.seed.solution_generator(u0, rhs, seed_time),\n        0,\n        self.seed_steps_per_step * seed_steps + 1,\n        self.seed_steps_per_step,\n    ):\n        yield u\n        fs.append(rhs(t, u))\n        t += time.spacing\n\n    for t in time.array[seed_steps:-1]:\n        u = self.update(t, u, rhs, fs, time.spacing)\n        yield u\n        fs.append(rhs(t + time.spacing, u))\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AM2","title":"<code>AM2</code>","text":"<p>               Bases: <code>AdamsMoultonAbstract</code></p> <p>Adams Moulton of order 3.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>class AM2(AdamsMoultonAbstract):\n    \"\"\"Adams Moulton of order 3.\"\"\"\n\n    @property\n    def order(self):\n        return 3\n\n    @property\n    def name(self):\n        return f\"AM2 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [5 / 12, 8 / 12, -1 / 12]\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AM3","title":"<code>AM3</code>","text":"<p>               Bases: <code>AdamsMoultonAbstract</code></p> <p>Adams Moulton of order 4.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>class AM3(AdamsMoultonAbstract):\n    \"\"\"Adams Moulton of order 4.\"\"\"\n\n    @property\n    def order(self):\n        return 4\n\n    @property\n    def name(self):\n        return f\"AM3 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [9 / 24, 19 / 24, -5 / 24, 1 / 24]\n</code></pre>"},{"location":"reference/adams_moulton/#odeiter.adams_moulton.AM4","title":"<code>AM4</code>","text":"<p>               Bases: <code>AdamsMoultonAbstract</code></p> <p>Adams Moulton of order 5.</p> Source code in <code>src/odeiter/adams_moulton.py</code> <pre><code>class AM4(AdamsMoultonAbstract):\n    \"\"\"Adams Moulton of order 5.\"\"\"\n\n    @property\n    def order(self):\n        return 5\n\n    @property\n    def name(self):\n        return f\"AM4 (seed: {self.seed.name})\"\n\n    @property\n    def fs_coeffs(self) -&gt; list[float]:\n        return [251 / 720, 646 / 720, -264 / 720, 106 / 720, -19 / 720]\n</code></pre>"},{"location":"reference/backward_differentiation/","title":"backward_differentiation","text":"<p>Backward Differentiation (BDF) solvers are a family of implicit solvers that perform a single right-hand-side solve per time step and achieve high-order accuracy by storing the solution at several previous time steps.</p> <p>BDF methods are mult-step solvers and thus require not only an initial condition, but also the solution at the first few time points dependeing on the order of the method. For example, BDF3 requires the solution at times \\(t_0, t_0+k, t_0+2k\\) where \\(t_0\\) is the inital time and \\(k\\) is the temporal step-size.</p> <p>This implementation assumes that you only have the solution at \\(t_0\\) and accepts another time-integrator as a seed. For example, we may use RK4 (a single step method). You must also decide the step-size of the single-step method such that the step-size of the Adams-Moulton solver is an integer multiple.</p> <p>For example, <pre><code>    solver = BDF5(RK4(), seed_steps_per_step=2)\n</code></pre> Will use the initial condition and RK4 to take 8 time times steps each at half the step size. This will generate solutions at times \\(t_0, t_0 + k/2, t_0 + k, t0 + 3k/2, ..., t_0 + 4k\\). It will then subsample these as necessary to use as appropriate seed steps.</p> <p>It is important to ensure that the order of the seed method and the number of seed steps per step are at least as accurate as the orer of the BDF method. For example <pre><code>solver = BDF5(RK4(), seed_steps_per_step=1)\n</code></pre> would not give a fifth order method because RK4 will generate seed steps up to fourth order accuracy. In contrast <pre><code>solver = BDF5(RK4(), seed_steps_per_step=2)\n</code></pre> will generate seed steps to eighth order accuracy, relative to the step size of the BDF solver.</p>"},{"location":"reference/backward_differentiation/#backward_differentiation","title":"backward_differentiation","text":""},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract","title":"<code>BackwardDifferentiationAbstract</code>","text":"<p>               Bases: <code>TimeIntegrator</code></p> <p>An abstract class for Backward Differentiation (BDF) solvers. All BDF solvers will inherit these methods. Additionally, they inherit the methods of <code>time_integrator.TimeIntegrator</code> as well.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>class BackwardDifferentiationAbstract(TimeIntegrator):\n    \"\"\"\n    An abstract class for Backward Differentiation (BDF) solvers.\n    All BDF solvers will inherit these methods. Additionally,\n    they inherit the methods of [`time_integrator.TimeIntegrator`](time_integrator.md)\n    as well.\n    \"\"\"\n\n    def __init__(\n        self,\n        seed: TimeIntegrator,\n        seed_steps_per_step: int,\n        root_finder: RootFinder = DefaultRootFinder,\n    ):\n        \"\"\"\n        Parameters:\n            seed: another time integrator used to take the first few steps.\n            seed_steps_per_step: the number of seed steps taking per step\n                of the AB integrator.\n            root_finder: a function of the form `root_finder(f, u0)` that returns\n                the solution to `f(u) = 0` using `u0` as an approximate soluiton.\n        \"\"\"\n        self.seed = seed\n        self.seed_steps_per_step = seed_steps_per_step\n        self.seed_steps = self.order - 1\n        self.root_finder = root_finder.solve\n\n    @abstractproperty\n    def name(self) -&gt; str:\n        \"\"\"\n        Returns:\n            The name of the method\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def order(self) -&gt; int:\n        \"\"\"\n        Returns:\n            The order of the method\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def us_coeffs(self) -&gt; list[float]:\n        \"\"\"\n        Returns:\n            The solution interpolation coefficients of the method.\n        \"\"\"\n        ...\n\n    @abstractproperty\n    def f_coeff(self) -&gt; float:\n        \"\"\"\n        Returns:\n            The derivative interpolation coefficient of the method.\n        \"\"\"\n        ...\n\n    def update(\n        self,\n        t: float,\n        us: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        delta_t: float,\n    ) -&gt; np.ndarray[float]:\n        \"\"\"\n        Compute the next time step. You probably want `solution_generator` instead.\n\n        Parameters:\n            t: The current time.\n            us: The solution at the current time-step and several previous time-steps.\n            rhs: The right-hand-side of the system as a function `rhs(t, u) -&gt; u'`.\n            delta_t: the temporal step-size.\n\n        Returns:\n            The solution at the next time step.\n        \"\"\"\n        const_vec = sum(c * u for c, u in zip(self.us_coeffs[::-1], us))\n\n        def func(x):\n            return -x + const_vec + delta_t * self.f_coeff * rhs(t + delta_t, x)\n\n        return self.root_finder(func, us[-1])\n\n    def solution_generator(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; Generator[np.ndarray[float], None, None]:\n        \"\"\"Create a generator that yields the solution for each time in `time`.\n\n        Parameters:\n            u0: The initial condition of the system.\n                Must be the same size as the system.\n            rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n            time: The discretized time domain from.\n\n        Returns:\n            A generator that yields the solution at each time in `time.array`.\n        \"\"\"\n        seed_steps = self.order - 1\n        seed_time = TimeRay(\n            time.start,\n            time.spacing / self.seed_steps_per_step,\n        )\n        t = time.start\n        us = deque(maxlen=self.order)\n        for u in islice(\n            self.seed.solution_generator(u0, rhs, seed_time),\n            0,\n            self.seed_steps_per_step * seed_steps + 1,\n            self.seed_steps_per_step,\n        ):\n            yield u\n            us.append(u)\n\n        for t in time.array[seed_steps:-1]:\n            u = self.update(t, us, rhs, time.spacing)\n            yield u\n            us.append(u)\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.__init__","title":"<code>__init__(seed, seed_steps_per_step, root_finder=DefaultRootFinder)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>seed</code> <code>TimeIntegrator</code> <p>another time integrator used to take the first few steps.</p> required <code>seed_steps_per_step</code> <code>int</code> <p>the number of seed steps taking per step of the AB integrator.</p> required <code>root_finder</code> <code>RootFinder</code> <p>a function of the form <code>root_finder(f, u0)</code> that returns the solution to <code>f(u) = 0</code> using <code>u0</code> as an approximate soluiton.</p> <code>DefaultRootFinder</code> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>def __init__(\n    self,\n    seed: TimeIntegrator,\n    seed_steps_per_step: int,\n    root_finder: RootFinder = DefaultRootFinder,\n):\n    \"\"\"\n    Parameters:\n        seed: another time integrator used to take the first few steps.\n        seed_steps_per_step: the number of seed steps taking per step\n            of the AB integrator.\n        root_finder: a function of the form `root_finder(f, u0)` that returns\n            the solution to `f(u) = 0` using `u0` as an approximate soluiton.\n    \"\"\"\n    self.seed = seed\n    self.seed_steps_per_step = seed_steps_per_step\n    self.seed_steps = self.order - 1\n    self.root_finder = root_finder.solve\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.name","title":"<code>name()</code>","text":"<p>Returns:</p> Type Description <code>str</code> <p>The name of the method</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>@abstractproperty\ndef name(self) -&gt; str:\n    \"\"\"\n    Returns:\n        The name of the method\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.order","title":"<code>order()</code>","text":"<p>Returns:</p> Type Description <code>int</code> <p>The order of the method</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>@abstractproperty\ndef order(self) -&gt; int:\n    \"\"\"\n    Returns:\n        The order of the method\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.us_coeffs","title":"<code>us_coeffs()</code>","text":"<p>Returns:</p> Type Description <code>list[float]</code> <p>The solution interpolation coefficients of the method.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>@abstractproperty\ndef us_coeffs(self) -&gt; list[float]:\n    \"\"\"\n    Returns:\n        The solution interpolation coefficients of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.f_coeff","title":"<code>f_coeff()</code>","text":"<p>Returns:</p> Type Description <code>float</code> <p>The derivative interpolation coefficient of the method.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>@abstractproperty\ndef f_coeff(self) -&gt; float:\n    \"\"\"\n    Returns:\n        The derivative interpolation coefficient of the method.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.update","title":"<code>update(t, us, rhs, delta_t)</code>","text":"<p>Compute the next time step. You probably want <code>solution_generator</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>The current time.</p> required <code>us</code> <code>ndarray[float]</code> <p>The solution at the current time-step and several previous time-steps.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>The right-hand-side of the system as a function <code>rhs(t, u) -&gt; u'</code>.</p> required <code>delta_t</code> <code>float</code> <p>the temporal step-size.</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>The solution at the next time step.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>def update(\n    self,\n    t: float,\n    us: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    delta_t: float,\n) -&gt; np.ndarray[float]:\n    \"\"\"\n    Compute the next time step. You probably want `solution_generator` instead.\n\n    Parameters:\n        t: The current time.\n        us: The solution at the current time-step and several previous time-steps.\n        rhs: The right-hand-side of the system as a function `rhs(t, u) -&gt; u'`.\n        delta_t: the temporal step-size.\n\n    Returns:\n        The solution at the next time step.\n    \"\"\"\n    const_vec = sum(c * u for c, u in zip(self.us_coeffs[::-1], us))\n\n    def func(x):\n        return -x + const_vec + delta_t * self.f_coeff * rhs(t + delta_t, x)\n\n    return self.root_finder(func, us[-1])\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BackwardDifferentiationAbstract.solution_generator","title":"<code>solution_generator(u0, rhs, time)</code>","text":"<p>Create a generator that yields the solution for each time in <code>time</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>The initial condition of the system. Must be the same size as the system.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>The right-hand-side as a function with signature <code>rhs(t, u) -&gt; u'</code>.</p> required <code>time</code> <code>TimeDomain</code> <p>The discretized time domain from.</p> required <p>Returns:</p> Type Description <code>None</code> <p>A generator that yields the solution at each time in <code>time.array</code>.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>def solution_generator(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; Generator[np.ndarray[float], None, None]:\n    \"\"\"Create a generator that yields the solution for each time in `time`.\n\n    Parameters:\n        u0: The initial condition of the system.\n            Must be the same size as the system.\n        rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n        time: The discretized time domain from.\n\n    Returns:\n        A generator that yields the solution at each time in `time.array`.\n    \"\"\"\n    seed_steps = self.order - 1\n    seed_time = TimeRay(\n        time.start,\n        time.spacing / self.seed_steps_per_step,\n    )\n    t = time.start\n    us = deque(maxlen=self.order)\n    for u in islice(\n        self.seed.solution_generator(u0, rhs, seed_time),\n        0,\n        self.seed_steps_per_step * seed_steps + 1,\n        self.seed_steps_per_step,\n    ):\n        yield u\n        us.append(u)\n\n    for t in time.array[seed_steps:-1]:\n        u = self.update(t, us, rhs, time.spacing)\n        yield u\n        us.append(u)\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BDF2","title":"<code>BDF2</code>","text":"<p>               Bases: <code>BackwardDifferentiationAbstract</code></p> <p>Backward Differentiation of order 2.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>class BDF2(BackwardDifferentiationAbstract):\n    \"\"\"Backward Differentiation of order 2.\"\"\"\n\n    @property\n    def name(self):\n        return f\"BDF2 (seed: {self.seed.name})\"\n\n    @property\n    def order(self):\n        return 2\n\n    @property\n    def us_coeffs(self) -&gt; list[float]:\n        return [4 / 3, -1 / 3]\n\n    @property\n    def f_coeff(self) -&gt; float:\n        return 2 / 3\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BDF3","title":"<code>BDF3</code>","text":"<p>               Bases: <code>BackwardDifferentiationAbstract</code></p> <p>Backward Differentiation of order 3.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>class BDF3(BackwardDifferentiationAbstract):\n    \"\"\"Backward Differentiation of order 3.\"\"\"\n\n    @property\n    def name(self):\n        return f\"BDF3 (seed: {self.seed.name})\"\n\n    @property\n    def order(self):\n        return 3\n\n    @property\n    def us_coeffs(self) -&gt; list[float]:\n        return [18 / 11, -9 / 11, 2 / 11]\n\n    @property\n    def f_coeff(self) -&gt; float:\n        return 6 / 11\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BDF4","title":"<code>BDF4</code>","text":"<p>               Bases: <code>BackwardDifferentiationAbstract</code></p> <p>Backward Differentiation of order 4.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>class BDF4(BackwardDifferentiationAbstract):\n    \"\"\"Backward Differentiation of order 4.\"\"\"\n\n    @property\n    def name(self):\n        return f\"BDF4 (seed: {self.seed.name})\"\n\n    @property\n    def order(self):\n        return 4\n\n    @property\n    def us_coeffs(self) -&gt; list[float]:\n        return [48 / 25, -36 / 25, 16 / 25, -3 / 25]\n\n    @property\n    def f_coeff(self) -&gt; float:\n        return 12 / 25\n</code></pre>"},{"location":"reference/backward_differentiation/#odeiter.backward_differentiation.BDF5","title":"<code>BDF5</code>","text":"<p>               Bases: <code>BackwardDifferentiationAbstract</code></p> <p>Backward Differentiation of order 5.</p> Source code in <code>src/odeiter/backward_differentiation.py</code> <pre><code>class BDF5(BackwardDifferentiationAbstract):\n    \"\"\"Backward Differentiation of order 5.\"\"\"\n\n    @property\n    def name(self):\n        return f\"BDF5 (seed: {self.seed.name})\"\n\n    @property\n    def order(self):\n        return 5\n\n    @property\n    def us_coeffs(self) -&gt; list[float]:\n        return [300 / 137, -300 / 137, 200 / 137, -75 / 137, 12 / 137]\n\n    @property\n    def f_coeff(self) -&gt; float:\n        return 60 / 137\n</code></pre>"},{"location":"reference/callback_modifier/","title":"callback_modifier","text":""},{"location":"reference/callback_modifier/#odeiter.callback_modifier.callback_modifier","title":"<code>callback_modifier(callback)</code>","text":"<p>Some applications require us to modify the current solution before producing the next in the sequence. For example, integrating over a delta pulse analytically can be done by adding the magnitude of the delta to the solution. The motivating example for this however is for domain shifting. We simulate pulses on the real line by simulating over a finite portion of the real line. If the sim persists long enough then the pulse will eventually reach the artificial boundary and the result will be non-senical. If we dynamically change the window over which we are simulating we can effectively remove this boundary, provided the solution remains pulse-like and the width does not grow larger than we expect.</p> Source code in <code>src/odeiter/callback_modifier.py</code> <pre><code>def callback_modifier(callback: callable):\n    \"\"\"Some applications require us to modify the current solution before\n    producing the next in the sequence. For example, integrating over a delta\n    pulse analytically can be done by adding the magnitude of the delta to the\n    solution. The motivating example for this however is for domain shifting.\n    We simulate pulses on the real line by simulating over a finite portion of\n    the real line. If the sim persists long enough then the pulse will\n    eventually reach the artificial boundary and the result will be\n    non-senical. If we dynamically change the window over which we are\n    simulating we can effectively remove this boundary, provided the solution\n    remains pulse-like and the width does not grow larger than we expect.\"\"\"\n\n    def wrapper(cls):\n\n        class SingleStepModifier(cls):\n\n            def update(self, t, u, f, h):\n                t, u, f, h = callback(t, u, f, h)\n                return super().update(t, u, f, h)\n\n        return SingleStepModifier\n\n    return wrapper\n</code></pre>"},{"location":"reference/root_finder/","title":"root_finder","text":"<p>Implicit methods require solving systems of equations. This module provides an interface (wrapper) for such solvers.</p>"},{"location":"reference/root_finder/#odeiter.root_finder.RootFinder","title":"<code>RootFinder</code>","text":"<p>               Bases: <code>ABC</code></p> <p>An interface for root-finders used to solve systems in implicit methods.</p> Source code in <code>src/odeiter/root_finder.py</code> <pre><code>class RootFinder(ABC):\n    \"\"\"An interface for root-finders used to solve systems in\n    implicit methods.\n    \"\"\"\n\n    @abstractstaticmethod\n    def solve(\n        func: Callable[[np.ndarray[float]], np.ndarray[float]],\n        u0: np.ndarray[float],\n    ) -&gt; np.ndarray[float]:\n        \"\"\"\n        Parameters:\n            func: A function `f(u)`.\n            u0: An approximate solution to `f(u) = 0`.\n\n        Returns:\n            The solution `u` to `f(u) = 0`.\n\n        Raises:\n            ValueError: The solver fails to find a solution.\n        \"\"\"\n        ...\n</code></pre>"},{"location":"reference/root_finder/#odeiter.root_finder.RootFinder.solve","title":"<code>solve(func, u0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ndarray[float]], ndarray[float]]</code> <p>A function <code>f(u)</code>.</p> required <code>u0</code> <code>ndarray[float]</code> <p>An approximate solution to <code>f(u) = 0</code>.</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>The solution <code>u</code> to <code>f(u) = 0</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>The solver fails to find a solution.</p> Source code in <code>src/odeiter/root_finder.py</code> <pre><code>@abstractstaticmethod\ndef solve(\n    func: Callable[[np.ndarray[float]], np.ndarray[float]],\n    u0: np.ndarray[float],\n) -&gt; np.ndarray[float]:\n    \"\"\"\n    Parameters:\n        func: A function `f(u)`.\n        u0: An approximate solution to `f(u) = 0`.\n\n    Returns:\n        The solution `u` to `f(u) = 0`.\n\n    Raises:\n        ValueError: The solver fails to find a solution.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/root_finder/#odeiter.root_finder.DefaultRootFinder","title":"<code>DefaultRootFinder</code>","text":"<p>               Bases: <code>RootFinder</code></p> <p>A wrapper for <code>scipy.optimize.root</code>.</p> Source code in <code>src/odeiter/root_finder.py</code> <pre><code>class DefaultRootFinder(RootFinder):\n    \"\"\"A wrapper for [`scipy.optimize.root`](https://docs.scipy.org/doc/scipy/\n    reference/generated/scipy.optimize.root.html).\n    \"\"\"\n\n    @staticmethod\n    def solve(\n        func: Callable[[np.ndarray[float]], np.ndarray[float]],\n        u0: np.ndarray[float],\n    ):\n        sol = root(fun=func, x0=u0)\n        if not sol.success:\n            raise ValueError(sol)\n        return sol.x\n</code></pre>"},{"location":"reference/single_step/","title":"single_step","text":"<p>A collection of single-step solvers.</p>"},{"location":"reference/single_step/#odeiter.single_step.SingleStepMethod","title":"<code>SingleStepMethod</code>","text":"<p>               Bases: <code>TimeIntegrator</code></p> <p>A base class for single step solvers. All single step solvers inherit these methods as well as the methods from <code>time_integrator.TimeIntegrator</code>.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>class SingleStepMethod(TimeIntegrator):\n    \"\"\"A base class for single step solvers. All single step solvers\n    inherit these methods as well as the methods from\n    [`time_integrator.TimeIntegrator`](time_integrator.md).\n    \"\"\"\n\n    @abstractmethod\n    def update(\n        self,\n        t: float,\n        u: np.ndarray[float],\n        f: np.ndarray[float],\n        delta_t: float,\n    ) -&gt; np.ndarray[float]:\n        \"\"\"\n        Compute the next time step. You probably want `solution_generator` instead.\n\n        Parameters:\n            t: The current time.\n            u: The solution at the current time-step.\n            f: the right-hand-side at at the current time-step.\n            delta_t: the temporal step-size.\n\n        Returns:\n            The solution at the next time step.\n        \"\"\"\n        ...\n\n    def solution_generator(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; Generator[np.ndarray[float], None, None]:\n        \"\"\"Create a generator that yields the solution for each time in `time`.\n\n        Parameters:\n            u0: The initial condition of the system.\n                Must be the same size as the system.\n            rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n            time: The discretized time domain from.\n\n        Returns:\n            A generator that yields the solution at each time in `time.array`.\n        \"\"\"\n        u = u0\n        yield u\n        for t in time.array[:-1]:\n            u = self.update(t, u, rhs, time.spacing)\n            yield u\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.SingleStepMethod.update","title":"<code>update(t, u, f, delta_t)</code>  <code>abstractmethod</code>","text":"<p>Compute the next time step. You probably want <code>solution_generator</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>float</code> <p>The current time.</p> required <code>u</code> <code>ndarray[float]</code> <p>The solution at the current time-step.</p> required <code>f</code> <code>ndarray[float]</code> <p>the right-hand-side at at the current time-step.</p> required <code>delta_t</code> <code>float</code> <p>the temporal step-size.</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>The solution at the next time step.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>@abstractmethod\ndef update(\n    self,\n    t: float,\n    u: np.ndarray[float],\n    f: np.ndarray[float],\n    delta_t: float,\n) -&gt; np.ndarray[float]:\n    \"\"\"\n    Compute the next time step. You probably want `solution_generator` instead.\n\n    Parameters:\n        t: The current time.\n        u: The solution at the current time-step.\n        f: the right-hand-side at at the current time-step.\n        delta_t: the temporal step-size.\n\n    Returns:\n        The solution at the next time step.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.SingleStepMethod.solution_generator","title":"<code>solution_generator(u0, rhs, time)</code>","text":"<p>Create a generator that yields the solution for each time in <code>time</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>The initial condition of the system. Must be the same size as the system.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>The right-hand-side as a function with signature <code>rhs(t, u) -&gt; u'</code>.</p> required <code>time</code> <code>TimeDomain</code> <p>The discretized time domain from.</p> required <p>Returns:</p> Type Description <code>None</code> <p>A generator that yields the solution at each time in <code>time.array</code>.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>def solution_generator(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; Generator[np.ndarray[float], None, None]:\n    \"\"\"Create a generator that yields the solution for each time in `time`.\n\n    Parameters:\n        u0: The initial condition of the system.\n            Must be the same size as the system.\n        rhs: The right-hand-side as a function with signature `rhs(t, u) -&gt; u'`.\n        time: The discretized time domain from.\n\n    Returns:\n        A generator that yields the solution at each time in `time.array`.\n    \"\"\"\n    u = u0\n    yield u\n    for t in time.array[:-1]:\n        u = self.update(t, u, rhs, time.spacing)\n        yield u\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.Euler","title":"<code>Euler</code>","text":"<p>               Bases: <code>SingleStepMethod</code></p> <p>Forward Euler, a first order explicit method.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>class Euler(SingleStepMethod):\n    \"Forward Euler, a first order explicit method.\"\n\n    @property\n    def order(self):\n        return 1\n\n    @property\n    def name(self):\n        return \"Euler\"\n\n    def update(self, t, u, f, delta_t):\n        return u + delta_t * f(t, u)\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.EulerDelta","title":"<code>EulerDelta</code>","text":"<p>               Bases: <code>SingleStepMethod</code></p> <p>Forward Euler, but analytically integrates a delta forcing term at a single point in time.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>class EulerDelta(SingleStepMethod):\n    \"\"\"Forward Euler, but analytically integrates a delta\n    forcing term at a single point in time.\n    \"\"\"\n\n    def __init__(self, delta_time: float, delta_profile: np.ndarray[float]):\n        \"\"\"\n        Parameters:\n            delta_time: the time at which the delta function is non-zero.\n            delta_profile: the magnitude of the delta for each\n                dimesion of the system.\n        \"\"\"\n        self.delta_time = delta_time\n        self.delta_profile = delta_profile\n\n    @property\n    def order(self):\n        return 1\n\n    @property\n    def name(self):\n        return \"Euler-Delta\"\n\n    def update(self, t, u, f, delta_t):\n        u_new = u + delta_t * f(t, u)\n        if abs(t - self.delta_time) &lt; delta_t / 2:\n            u_new += self.delta_profile\n        return u_new\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.EulerDelta.__init__","title":"<code>__init__(delta_time, delta_profile)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>delta_time</code> <code>float</code> <p>the time at which the delta function is non-zero.</p> required <code>delta_profile</code> <code>ndarray[float]</code> <p>the magnitude of the delta for each dimesion of the system.</p> required Source code in <code>src/odeiter/single_step.py</code> <pre><code>def __init__(self, delta_time: float, delta_profile: np.ndarray[float]):\n    \"\"\"\n    Parameters:\n        delta_time: the time at which the delta function is non-zero.\n        delta_profile: the magnitude of the delta for each\n            dimesion of the system.\n    \"\"\"\n    self.delta_time = delta_time\n    self.delta_profile = delta_profile\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.RK4","title":"<code>RK4</code>","text":"<p>               Bases: <code>SingleStepMethod</code></p> <p>Runge-Kutta order 4.</p> <p>A single-step method that performs 4 function evaluations per time step. Often used as a default because of it's robust domain of stability and it's high order of accuracy.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>class RK4(SingleStepMethod):\n    \"\"\"\n    Runge-Kutta order 4.\n\n    A single-step method that performs 4 function evaluations per time\n    step. Often used as a default because of it's robust domain of stability\n    and it's high order of accuracy.\n    \"\"\"\n\n    @property\n    def name(self):\n        return \"RK4\"\n\n    @property\n    def order(self):\n        return 4\n\n    def update(self, t, u, f, delta_t):\n        k1 = f(t, u)\n        k2 = f(t + delta_t / 2, u + delta_t / 2 * k1)\n        k3 = f(t + delta_t / 2, u + delta_t / 2 * k2)\n        k4 = f(t + delta_t, u + delta_t * k3)\n        return u + delta_t / 6 * (k1 + 2 * k2 + 2 * k3 + k4)\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.ImplicitEuler","title":"<code>ImplicitEuler</code>","text":"<p>               Bases: <code>SingleStepMethod</code></p> <p>An implicit method of order 1.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>class ImplicitEuler(SingleStepMethod):\n    \"\"\"An implicit method of order 1.\"\"\"\n\n    def __init__(self, root_finder: RootFinder = DefaultRootFinder):\n        \"\"\"\n        Parameters:\n            root_finder: A RootFinder object to solve the system\n                at each time step.\n        \"\"\"\n        self.root_finder = root_finder.solve\n\n    @property\n    def order(self):\n        return 1\n\n    @property\n    def name(self):\n        return \"Implicit Euler\"\n\n    def update(self, t, u, f, delta_t):\n        def func(x):\n            return -x + u + delta_t * f(t + delta_t, x)\n\n        return self.root_finder(func, u)\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.ImplicitEuler.__init__","title":"<code>__init__(root_finder=DefaultRootFinder)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>root_finder</code> <code>RootFinder</code> <p>A RootFinder object to solve the system at each time step.</p> <code>DefaultRootFinder</code> Source code in <code>src/odeiter/single_step.py</code> <pre><code>def __init__(self, root_finder: RootFinder = DefaultRootFinder):\n    \"\"\"\n    Parameters:\n        root_finder: A RootFinder object to solve the system\n            at each time step.\n    \"\"\"\n    self.root_finder = root_finder.solve\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.Trapezoidal","title":"<code>Trapezoidal</code>","text":"<p>               Bases: <code>SingleStepMethod</code></p> <p>An implicit method of order 2.</p> Source code in <code>src/odeiter/single_step.py</code> <pre><code>class Trapezoidal(SingleStepMethod):\n    \"\"\"An implicit method of order 2.\"\"\"\n\n    def __init__(self, root_finder: RootFinder = DefaultRootFinder):\n        \"\"\"\n        Parameters:\n            root_finder: A RootFinder object to solve the system\n                at each time step.\n        \"\"\"\n        self.root_finder = root_finder.solve\n\n    @property\n    def order(self):\n        return 2\n\n    @property\n    def name(self):\n        return \"Trapezoidal\"\n\n    def update(self, t, u, f, delta_t):\n        fn = f(t, u)\n\n        def func(x):\n            return -x + u + delta_t / 2 * (fn + f(t + delta_t, x))\n\n        return self.root_finder(func, u)\n</code></pre>"},{"location":"reference/single_step/#odeiter.single_step.Trapezoidal.__init__","title":"<code>__init__(root_finder=DefaultRootFinder)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>root_finder</code> <code>RootFinder</code> <p>A RootFinder object to solve the system at each time step.</p> <code>DefaultRootFinder</code> Source code in <code>src/odeiter/single_step.py</code> <pre><code>def __init__(self, root_finder: RootFinder = DefaultRootFinder):\n    \"\"\"\n    Parameters:\n        root_finder: A RootFinder object to solve the system\n            at each time step.\n    \"\"\"\n    self.root_finder = root_finder.solve\n</code></pre>"},{"location":"reference/time_domain/","title":"time_domain","text":"<p>A collection of time-discretizations required for odeiter solvers.</p>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeDomain","title":"<code>TimeDomain</code>","text":"<p>An iterable class representing the discretization of a temporal domain. This is used as an input to the <code>odeiter.time_integrator.TimeInterator</code> solvers.</p> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>class TimeDomain:\n    \"\"\"\n    An iterable class representing the discretization of a temporal domain.\n    This is used as an input to the `odeiter.time_integrator.TimeInterator` solvers.\n    \"\"\"\n\n    def __init__(self, start: float, spacing: float, steps: int):\n        \"\"\"\n        A discretization of the interval $[\\\\text{start},\\\\  \\\\text{start} +\n        \\\\text{spacing}\\\\cdot\\\\text{steps}]$.\n\n        Parameters:\n            start: The inital time.\n            spacing: The space between time-steps.\n            steps: The total number of time steps.\n\n        Examples:\n            &gt;&gt;&gt; t0 = 0\n            &gt;&gt;&gt; dt = 0.1\n            &gt;&gt;&gt; steps = 5\n            &gt;&gt;&gt; time = TimeDomain(t0, dt, steps)\n            &gt;&gt;&gt; print(time.array)\n            [0.  0.1 0.2 0.3 0.4 0.5]\n        \"\"\"\n        self.start = start\n        self.spacing = spacing\n        self.steps = steps\n        self.initialze_array()\n\n    def initialze_array(self):\n        self.array = self.start + self.spacing * np.arange(self.steps + 1, dtype=float)\n\n    def __iter__(self):\n        yield from self.array\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeDomain.__init__","title":"<code>__init__(start, spacing, steps)</code>","text":"<p>A discretization of the interval \\([\\text{start},\\  \\text{start} + \\text{spacing}\\cdot\\text{steps}]\\).</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>The inital time.</p> required <code>spacing</code> <code>float</code> <p>The space between time-steps.</p> required <code>steps</code> <code>int</code> <p>The total number of time steps.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; t0 = 0\n&gt;&gt;&gt; dt = 0.1\n&gt;&gt;&gt; steps = 5\n&gt;&gt;&gt; time = TimeDomain(t0, dt, steps)\n&gt;&gt;&gt; print(time.array)\n[0.  0.1 0.2 0.3 0.4 0.5]\n</code></pre> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>def __init__(self, start: float, spacing: float, steps: int):\n    \"\"\"\n    A discretization of the interval $[\\\\text{start},\\\\  \\\\text{start} +\n    \\\\text{spacing}\\\\cdot\\\\text{steps}]$.\n\n    Parameters:\n        start: The inital time.\n        spacing: The space between time-steps.\n        steps: The total number of time steps.\n\n    Examples:\n        &gt;&gt;&gt; t0 = 0\n        &gt;&gt;&gt; dt = 0.1\n        &gt;&gt;&gt; steps = 5\n        &gt;&gt;&gt; time = TimeDomain(t0, dt, steps)\n        &gt;&gt;&gt; print(time.array)\n        [0.  0.1 0.2 0.3 0.4 0.5]\n    \"\"\"\n    self.start = start\n    self.spacing = spacing\n    self.steps = steps\n    self.initialze_array()\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeDomain_Start_Stop_MaxSpacing","title":"<code>TimeDomain_Start_Stop_MaxSpacing</code>","text":"<p>               Bases: <code>TimeDomain</code></p> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>class TimeDomain_Start_Stop_MaxSpacing(TimeDomain):\n    def __init__(self, start: float, stop: float, max_spacing: float):\n        \"\"\"An iterable discretization of the inverval $[\\\\text{start},\\\\ \\\\text{stop}]$\n        with a spacing of `max_spacing` or smaller.\n\n        Parameters:\n            start: The initial time.\n            stop: The final time.\n            max_spacing: an upper bound on the temporal step-size.\n\n        Examples:\n            &gt;&gt;&gt; t0 = 0\n            &gt;&gt;&gt; tf = 0.5\n            &gt;&gt;&gt; max_dt = 0.11\n            &gt;&gt;&gt; time = TimeDomain_Start_Stop_MaxSpacing(t0, tf, max_dt)\n            &gt;&gt;&gt; print(time.array)\n            [0.  0.1 0.2 0.3 0.4 0.5]\n        \"\"\"\n        self.start = start\n        self.steps = math.ceil((stop - start) / max_spacing)\n        self.spacing = (stop - start) / self.steps\n        self.initialze_array()\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeDomain_Start_Stop_MaxSpacing.__init__","title":"<code>__init__(start, stop, max_spacing)</code>","text":"<p>An iterable discretization of the inverval \\([\\text{start},\\ \\text{stop}]\\) with a spacing of <code>max_spacing</code> or smaller.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>The initial time.</p> required <code>stop</code> <code>float</code> <p>The final time.</p> required <code>max_spacing</code> <code>float</code> <p>an upper bound on the temporal step-size.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; t0 = 0\n&gt;&gt;&gt; tf = 0.5\n&gt;&gt;&gt; max_dt = 0.11\n&gt;&gt;&gt; time = TimeDomain_Start_Stop_MaxSpacing(t0, tf, max_dt)\n&gt;&gt;&gt; print(time.array)\n[0.  0.1 0.2 0.3 0.4 0.5]\n</code></pre> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>def __init__(self, start: float, stop: float, max_spacing: float):\n    \"\"\"An iterable discretization of the inverval $[\\\\text{start},\\\\ \\\\text{stop}]$\n    with a spacing of `max_spacing` or smaller.\n\n    Parameters:\n        start: The initial time.\n        stop: The final time.\n        max_spacing: an upper bound on the temporal step-size.\n\n    Examples:\n        &gt;&gt;&gt; t0 = 0\n        &gt;&gt;&gt; tf = 0.5\n        &gt;&gt;&gt; max_dt = 0.11\n        &gt;&gt;&gt; time = TimeDomain_Start_Stop_MaxSpacing(t0, tf, max_dt)\n        &gt;&gt;&gt; print(time.array)\n        [0.  0.1 0.2 0.3 0.4 0.5]\n    \"\"\"\n    self.start = start\n    self.steps = math.ceil((stop - start) / max_spacing)\n    self.spacing = (stop - start) / self.steps\n    self.initialze_array()\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeDomain_Start_Stop_Steps","title":"<code>TimeDomain_Start_Stop_Steps</code>","text":"<p>               Bases: <code>TimeDomain</code></p> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>class TimeDomain_Start_Stop_Steps(TimeDomain):\n    def __init__(self, start: float, stop: float, steps: int):\n        \"\"\"An iterable discretization of the inverval $[\\\\text{start},\\\\ \\\\text{stop}]$\n        with $\\\\text{steps} + 1$ equally spaced ponits.\n\n        Parameters:\n            start: The initial time.\n            stop: The final time.\n            steps: The number of time steps.\n\n        Examples:\n            &gt;&gt;&gt; t0 = 0\n            &gt;&gt;&gt; tf = 0.5\n            &gt;&gt;&gt; steps = 5\n            &gt;&gt;&gt; time = TimeDomain_Start_Stop_Steps(t0, tf, steps)\n            &gt;&gt;&gt; print(time.array)\n            [0.  0.1 0.2 0.3 0.4 0.5]\n        \"\"\"\n        self.start = start\n        self.steps = steps\n        self.spacing = (stop - start) / steps\n        self.initialze_array()\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeDomain_Start_Stop_Steps.__init__","title":"<code>__init__(start, stop, steps)</code>","text":"<p>An iterable discretization of the inverval \\([\\text{start},\\ \\text{stop}]\\) with \\(\\text{steps} + 1\\) equally spaced ponits.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>The initial time.</p> required <code>stop</code> <code>float</code> <p>The final time.</p> required <code>steps</code> <code>int</code> <p>The number of time steps.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; t0 = 0\n&gt;&gt;&gt; tf = 0.5\n&gt;&gt;&gt; steps = 5\n&gt;&gt;&gt; time = TimeDomain_Start_Stop_Steps(t0, tf, steps)\n&gt;&gt;&gt; print(time.array)\n[0.  0.1 0.2 0.3 0.4 0.5]\n</code></pre> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>def __init__(self, start: float, stop: float, steps: int):\n    \"\"\"An iterable discretization of the inverval $[\\\\text{start},\\\\ \\\\text{stop}]$\n    with $\\\\text{steps} + 1$ equally spaced ponits.\n\n    Parameters:\n        start: The initial time.\n        stop: The final time.\n        steps: The number of time steps.\n\n    Examples:\n        &gt;&gt;&gt; t0 = 0\n        &gt;&gt;&gt; tf = 0.5\n        &gt;&gt;&gt; steps = 5\n        &gt;&gt;&gt; time = TimeDomain_Start_Stop_Steps(t0, tf, steps)\n        &gt;&gt;&gt; print(time.array)\n        [0.  0.1 0.2 0.3 0.4 0.5]\n    \"\"\"\n    self.start = start\n    self.steps = steps\n    self.spacing = (stop - start) / steps\n    self.initialze_array()\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeRay","title":"<code>TimeRay</code>","text":"<p>               Bases: <code>TimeDomain</code></p> <p>A variant of Timedomain that has no end time.</p> <p>Only use this with odeiter.TimeIntegrator.solution_generator. This is effectively a while-loop, so always program a termination condition.</p> <p>Do not use this with odeiter.TimeIntegrator.solve or odeiter.TimeIntgegraor.t_final. Doing so will resut in an infinite loop.</p> <p>This is useful for simulating a system into the future for an amount of time that is unkown from the start. For example, simulating until the difference between two solutions is above a threshold.</p> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>class TimeRay(TimeDomain):\n    \"\"\"\n    A variant of Timedomain that has no end time.\n\n    Only use this with odeiter.TimeIntegrator.solution_generator.\n    This is effectively a while-loop, so always program a termination condition.\n\n    Do not use this with odeiter.TimeIntegrator.solve or odeiter.TimeIntgegraor.t_final.\n    Doing so will resut in an infinite loop.\n\n    This is useful for simulating a system into the future for an amount of time that is\n    unkown from the start. For example, simulating until the difference between two\n    solutions is above a threshold.\n    \"\"\"\n\n    def __init__(self, start: float, spacing: float):\n        \"\"\"An iterable discretization of the inverval $[\\\\text{start},\\\\ \\\\infty)$\n        with with `spacing` space between points.\n\n        Parameters:\n            start: The initial time.\n            spacing: The space between time-steps.\n\n        Examples:\n            &gt;&gt;&gt; t0 = 0\n            &gt;&gt;&gt; spacing = 0.1\n            &gt;&gt;&gt; time = TimeRay(t0, spacing)\n            &gt;&gt;&gt; for t, _ in zip(time, range(6)):\n            ...     print(t)\n            0.0\n            0.1\n            0.2\n            0.30000000000000004\n            0.4\n            0.5\n        \"\"\"\n        self.start = start\n        self.spacing = spacing\n\n    @property\n    def array(self):\n        return Ray(self.start, self.spacing)\n\n    def __iter__(self):\n        return self.array.__iter__()\n</code></pre>"},{"location":"reference/time_domain/#odeiter.time_domain.TimeRay.__init__","title":"<code>__init__(start, spacing)</code>","text":"<p>An iterable discretization of the inverval \\([\\text{start},\\ \\infty)\\) with with <code>spacing</code> space between points.</p> <p>Parameters:</p> Name Type Description Default <code>start</code> <code>float</code> <p>The initial time.</p> required <code>spacing</code> <code>float</code> <p>The space between time-steps.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; t0 = 0\n&gt;&gt;&gt; spacing = 0.1\n&gt;&gt;&gt; time = TimeRay(t0, spacing)\n&gt;&gt;&gt; for t, _ in zip(time, range(6)):\n...     print(t)\n0.0\n0.1\n0.2\n0.30000000000000004\n0.4\n0.5\n</code></pre> Source code in <code>src/odeiter/time_domain.py</code> <pre><code>def __init__(self, start: float, spacing: float):\n    \"\"\"An iterable discretization of the inverval $[\\\\text{start},\\\\ \\\\infty)$\n    with with `spacing` space between points.\n\n    Parameters:\n        start: The initial time.\n        spacing: The space between time-steps.\n\n    Examples:\n        &gt;&gt;&gt; t0 = 0\n        &gt;&gt;&gt; spacing = 0.1\n        &gt;&gt;&gt; time = TimeRay(t0, spacing)\n        &gt;&gt;&gt; for t, _ in zip(time, range(6)):\n        ...     print(t)\n        0.0\n        0.1\n        0.2\n        0.30000000000000004\n        0.4\n        0.5\n    \"\"\"\n    self.start = start\n    self.spacing = spacing\n</code></pre>"},{"location":"reference/time_integrator/","title":"time_integrator","text":"<p>The <code>time_integrator</code> module contains a base class for solvers.</p> <p>For concrete classes see:</p> <ul> <li><code>odeiter.adams_bashforth</code></li> <li><code>odeiter.adams_moulton</code></li> <li><code>odeiter.backward_differentiation</code></li> <li><code>odeiter.single_step</code></li> </ul> <p>If you're unsure what you're looking for, try <code>odeiter.RK4</code> </p>"},{"location":"reference/time_integrator/#odeiter.time_integrator.TimeIntegrator","title":"<code>TimeIntegrator</code>","text":"<p>               Bases: <code>ABC</code></p> <p>A base class for solvers.</p> Source code in <code>src/odeiter/time_integrator.py</code> <pre><code>class TimeIntegrator(ABC):\n    \"\"\"A base class for solvers.\"\"\"\n\n    @abstractproperty\n    def name(self) -&gt; str:\n        ...\n\n    @abstractproperty\n    def order(self) -&gt; int:\n        \"\"\"The order of the method. If this method is order $o$\n        then cutting the time-step in half should reduce the error\n        by a factor of $(1/2)^o$.\n\n        This is limited by machine precision. Additionally, it may not exhibit\n        this convergence behavior if the time step is too large, or if the\n        forcing term is not smooth enough.\n        \"\"\"\n        ...\n\n    @abstractmethod\n    def solution_generator(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; Generator[np.ndarray[float], None, None]:\n        \"\"\"\n        Return a generator that yields the solution at each time in time.array.\n\n        Parameters:\n            u0: a numpy array of initial conditions. It should have the same shape as\n                the solution at each time step.\n            rhs: A function rhs(t, u) that is the right-hand-side of the equation\n                 u' = rhs(t, u).\n            time: An odeiter.TimeDomain instance.\n\n        Returns:\n            a generator that yeilds the solution at each time\n            step in time.array.\n        \"\"\"\n        ...\n\n    def solve(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; list[np.ndarray[float]]:\n        \"\"\"\n        Return a list of the solutions at each time for times in time.array.\n        Equivalent to `list(solver.solution_generator(u0, rhs, time))`.\n\n        Parameters:\n            u0: a numpy array of initial conditions. It should have the same shape as\n                the solution at each time step.\n            rhs: A function rhs(t, u) that is the right-hand-side of the equation\n                 u' = rhs(t, u).\n            time: An odeiter.TimeDomain instance.\n\n        Returns:\n            A list of the solution at each time in `time.array`.\n        \"\"\"\n        return list(self.solution_generator(u0, rhs, time))\n\n    def t_final(\n        self,\n        u0: np.ndarray[float],\n        rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n        time: TimeDomain,\n    ) -&gt; np.ndarray[float]:\n        \"\"\"\n        Returns the solution at the final time `time.array[-1]`.\n        Equivalent to `solver.solve[-1]`.\n\n        Parameters:\n            u0: a numpy array of initial conditions. It should have the same shape as\n                the solution at each time step.\n            rhs: A function rhs(t, u) that is the right-hand-side of the equation\n                 u' = rhs(t, u).\n            time: An odeiter.TimeDomain instance.\n\n        Returns:\n            The solution at the final time.\n        \"\"\"\n        for u in self.solution_generator(u0, rhs, time):\n            pass\n        return u\n</code></pre>"},{"location":"reference/time_integrator/#odeiter.time_integrator.TimeIntegrator.order","title":"<code>order()</code>","text":"<p>The order of the method. If this method is order \\(o\\) then cutting the time-step in half should reduce the error by a factor of \\((1/2)^o\\).</p> <p>This is limited by machine precision. Additionally, it may not exhibit this convergence behavior if the time step is too large, or if the forcing term is not smooth enough.</p> Source code in <code>src/odeiter/time_integrator.py</code> <pre><code>@abstractproperty\ndef order(self) -&gt; int:\n    \"\"\"The order of the method. If this method is order $o$\n    then cutting the time-step in half should reduce the error\n    by a factor of $(1/2)^o$.\n\n    This is limited by machine precision. Additionally, it may not exhibit\n    this convergence behavior if the time step is too large, or if the\n    forcing term is not smooth enough.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/time_integrator/#odeiter.time_integrator.TimeIntegrator.solution_generator","title":"<code>solution_generator(u0, rhs, time)</code>  <code>abstractmethod</code>","text":"<p>Return a generator that yields the solution at each time in time.array.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>a numpy array of initial conditions. It should have the same shape as the solution at each time step.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>A function rhs(t, u) that is the right-hand-side of the equation  u' = rhs(t, u).</p> required <code>time</code> <code>TimeDomain</code> <p>An odeiter.TimeDomain instance.</p> required <p>Returns:</p> Type Description <code>None</code> <p>a generator that yeilds the solution at each time</p> <code>None</code> <p>step in time.array.</p> Source code in <code>src/odeiter/time_integrator.py</code> <pre><code>@abstractmethod\ndef solution_generator(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; Generator[np.ndarray[float], None, None]:\n    \"\"\"\n    Return a generator that yields the solution at each time in time.array.\n\n    Parameters:\n        u0: a numpy array of initial conditions. It should have the same shape as\n            the solution at each time step.\n        rhs: A function rhs(t, u) that is the right-hand-side of the equation\n             u' = rhs(t, u).\n        time: An odeiter.TimeDomain instance.\n\n    Returns:\n        a generator that yeilds the solution at each time\n        step in time.array.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/time_integrator/#odeiter.time_integrator.TimeIntegrator.solve","title":"<code>solve(u0, rhs, time)</code>","text":"<p>Return a list of the solutions at each time for times in time.array. Equivalent to <code>list(solver.solution_generator(u0, rhs, time))</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>a numpy array of initial conditions. It should have the same shape as the solution at each time step.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>A function rhs(t, u) that is the right-hand-side of the equation  u' = rhs(t, u).</p> required <code>time</code> <code>TimeDomain</code> <p>An odeiter.TimeDomain instance.</p> required <p>Returns:</p> Type Description <code>list[ndarray[float]]</code> <p>A list of the solution at each time in <code>time.array</code>.</p> Source code in <code>src/odeiter/time_integrator.py</code> <pre><code>def solve(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; list[np.ndarray[float]]:\n    \"\"\"\n    Return a list of the solutions at each time for times in time.array.\n    Equivalent to `list(solver.solution_generator(u0, rhs, time))`.\n\n    Parameters:\n        u0: a numpy array of initial conditions. It should have the same shape as\n            the solution at each time step.\n        rhs: A function rhs(t, u) that is the right-hand-side of the equation\n             u' = rhs(t, u).\n        time: An odeiter.TimeDomain instance.\n\n    Returns:\n        A list of the solution at each time in `time.array`.\n    \"\"\"\n    return list(self.solution_generator(u0, rhs, time))\n</code></pre>"},{"location":"reference/time_integrator/#odeiter.time_integrator.TimeIntegrator.t_final","title":"<code>t_final(u0, rhs, time)</code>","text":"<p>Returns the solution at the final time <code>time.array[-1]</code>. Equivalent to <code>solver.solve[-1]</code>.</p> <p>Parameters:</p> Name Type Description Default <code>u0</code> <code>ndarray[float]</code> <p>a numpy array of initial conditions. It should have the same shape as the solution at each time step.</p> required <code>rhs</code> <code>Callable[[float, ndarray[float]], ndarray[float]]</code> <p>A function rhs(t, u) that is the right-hand-side of the equation  u' = rhs(t, u).</p> required <code>time</code> <code>TimeDomain</code> <p>An odeiter.TimeDomain instance.</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>The solution at the final time.</p> Source code in <code>src/odeiter/time_integrator.py</code> <pre><code>def t_final(\n    self,\n    u0: np.ndarray[float],\n    rhs: Callable[[float, np.ndarray[float]], np.ndarray[float]],\n    time: TimeDomain,\n) -&gt; np.ndarray[float]:\n    \"\"\"\n    Returns the solution at the final time `time.array[-1]`.\n    Equivalent to `solver.solve[-1]`.\n\n    Parameters:\n        u0: a numpy array of initial conditions. It should have the same shape as\n            the solution at each time step.\n        rhs: A function rhs(t, u) that is the right-hand-side of the equation\n             u' = rhs(t, u).\n        time: An odeiter.TimeDomain instance.\n\n    Returns:\n        The solution at the final time.\n    \"\"\"\n    for u in self.solution_generator(u0, rhs, time):\n        pass\n    return u\n</code></pre>"}]}